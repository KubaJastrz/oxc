// Generated by `scripts/build.mjs`.

#![allow(
    unsafe_code,
    clippy::missing_safety_doc,
    clippy::missing_panics_doc,
    clippy::undocumented_unsafe_blocks,
    clippy::semicolon_if_nothing_returned,
    clippy::ptr_as_ptr
)]

use std::{marker::PhantomData, mem::offset_of};

use oxc_allocator::Vec;

use super::{ancestor, Ancestor, Traverse, TraverseCtx};
use crate::ast::*;

pub(super) fn walk_program<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Program<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_program(node, ctx);
    let field = &mut node.directives;
    let other_field = &mut node.source_type;
    ctx.push_stack(Ancestor::ProgramDirectives(ancestor::ProgramWithoutDirectives(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Program, source_type)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_directive(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.hashbang;
    if let Some(field) = field {
        let other_field = &mut node.directives;
        ctx.push_stack(Ancestor::ProgramHashbang(ancestor::ProgramWithoutHashbang(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Program, directives)) },
            PhantomData,
        )));
        walk_hashbang(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.body;
    let other_field = &mut node.hashbang;
    ctx.push_stack(Ancestor::ProgramBody(ancestor::ProgramWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Program, hashbang)) },
        PhantomData,
    )));
    walk_statements(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_program(node, ctx);
}

pub(super) fn walk_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Expression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_expression(node, ctx);
    match node {
        Expression::BooleanLiteral(node) => walk_boolean_literal(traverser, node, ctx),
        Expression::NullLiteral(node) => walk_null_literal(traverser, node, ctx),
        Expression::NumericLiteral(node) => walk_numeric_literal(traverser, node, ctx),
        Expression::BigintLiteral(node) => walk_big_int_literal(traverser, node, ctx),
        Expression::RegExpLiteral(node) => walk_reg_exp_literal(traverser, node, ctx),
        Expression::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
        Expression::TemplateLiteral(node) => walk_template_literal(traverser, node, ctx),
        Expression::Identifier(node) => walk_identifier_reference(traverser, node, ctx),
        Expression::MetaProperty(node) => walk_meta_property(traverser, node, ctx),
        Expression::Super(node) => walk_super(traverser, node, ctx),
        Expression::ArrayExpression(node) => walk_array_expression(traverser, node, ctx),
        Expression::ArrowFunctionExpression(node) => {
            walk_arrow_function_expression(traverser, node, ctx)
        }
        Expression::AssignmentExpression(node) => walk_assignment_expression(traverser, node, ctx),
        Expression::AwaitExpression(node) => walk_await_expression(traverser, node, ctx),
        Expression::BinaryExpression(node) => walk_binary_expression(traverser, node, ctx),
        Expression::CallExpression(node) => walk_call_expression(traverser, node, ctx),
        Expression::ChainExpression(node) => walk_chain_expression(traverser, node, ctx),
        Expression::ClassExpression(node) => walk_class(traverser, node, ctx),
        Expression::ConditionalExpression(node) => {
            walk_conditional_expression(traverser, node, ctx)
        }
        Expression::FunctionExpression(node) => walk_function(traverser, node, ctx),
        Expression::ImportExpression(node) => walk_import_expression(traverser, node, ctx),
        Expression::LogicalExpression(node) => walk_logical_expression(traverser, node, ctx),
        Expression::NewExpression(node) => walk_new_expression(traverser, node, ctx),
        Expression::ObjectExpression(node) => walk_object_expression(traverser, node, ctx),
        Expression::ParenthesizedExpression(node) => {
            walk_parenthesized_expression(traverser, node, ctx)
        }
        Expression::SequenceExpression(node) => walk_sequence_expression(traverser, node, ctx),
        Expression::TaggedTemplateExpression(node) => {
            walk_tagged_template_expression(traverser, node, ctx)
        }
        Expression::ThisExpression(node) => walk_this_expression(traverser, node, ctx),
        Expression::UnaryExpression(node) => walk_unary_expression(traverser, node, ctx),
        Expression::UpdateExpression(node) => walk_update_expression(traverser, node, ctx),
        Expression::YieldExpression(node) => walk_yield_expression(traverser, node, ctx),
        Expression::PrivateInExpression(node) => walk_private_in_expression(traverser, node, ctx),
        Expression::JSXElement(node) => walk_jsx_element(traverser, node, ctx),
        Expression::JSXFragment(node) => walk_jsx_fragment(traverser, node, ctx),
        Expression::TSAsExpression(node) => walk_ts_as_expression(traverser, node, ctx),
        Expression::TSSatisfiesExpression(node) => {
            walk_ts_satisfies_expression(traverser, node, ctx)
        }
        Expression::TSTypeAssertion(node) => walk_ts_type_assertion(traverser, node, ctx),
        Expression::TSNonNullExpression(node) => walk_ts_non_null_expression(traverser, node, ctx),
        Expression::TSInstantiationExpression(node) => {
            walk_ts_instantiation_expression(traverser, node, ctx)
        }
        match_member_expression!(Expression) => {
            walk_member_expression(traverser, node.to_member_expression_mut(), ctx)
        }
    }
    traverser.exit_expression(node, ctx);
}

pub(super) fn walk_identifier_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut IdentifierName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_identifier_name(node, ctx);
    traverser.exit_identifier_name(node, ctx);
}

pub(super) fn walk_identifier_reference<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut IdentifierReference<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_identifier_reference(node, ctx);
    traverser.exit_identifier_reference(node, ctx);
}

pub(super) fn walk_binding_identifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BindingIdentifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_binding_identifier(node, ctx);
    traverser.exit_binding_identifier(node, ctx);
}

pub(super) fn walk_label_identifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut LabelIdentifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_label_identifier(node, ctx);
    traverser.exit_label_identifier(node, ctx);
}

pub(super) fn walk_this_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ThisExpression,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_this_expression(node, ctx);
    traverser.exit_this_expression(node, ctx);
}

pub(super) fn walk_array_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ArrayExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_array_expression(node, ctx);
    let field = &mut node.elements;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ArrayExpressionElements(ancestor::ArrayExpressionWithoutElements(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ArrayExpression, span)) },
    )));
    for field in field.iter_mut() {
        walk_array_expression_element(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_array_expression(node, ctx);
}

pub(super) fn walk_array_expression_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ArrayExpressionElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_array_expression_element(node, ctx);
    match node {
        ArrayExpressionElement::SpreadElement(node) => walk_spread_element(traverser, node, ctx),
        ArrayExpressionElement::Elision(node) => walk_elision(traverser, node, ctx),
        match_expression!(ArrayExpressionElement) => {
            walk_expression(traverser, node.to_expression_mut(), ctx)
        }
    }
    traverser.exit_array_expression_element(node, ctx);
}

pub(super) fn walk_elision<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Elision,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_elision(node, ctx);
    traverser.exit_elision(node, ctx);
}

pub(super) fn walk_object_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ObjectExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_object_expression(node, ctx);
    let field = &mut node.properties;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ObjectExpressionProperties(
        ancestor::ObjectExpressionWithoutProperties(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ObjectExpression, span))
        }),
    ));
    for field in field.iter_mut() {
        walk_object_property_kind(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_object_expression(node, ctx);
}

pub(super) fn walk_object_property_kind<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ObjectPropertyKind<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_object_property_kind(node, ctx);
    match node {
        ObjectPropertyKind::ObjectProperty(node) => walk_object_property(traverser, node, ctx),
        ObjectPropertyKind::SpreadProperty(node) => walk_spread_element(traverser, node, ctx),
    }
    traverser.exit_object_property_kind(node, ctx);
}

pub(super) fn walk_object_property<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ObjectProperty<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_object_property(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ObjectPropertyKey(ancestor::ObjectPropertyWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ObjectProperty, span)) },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    let other_field = &mut node.key;
    ctx.push_stack(Ancestor::ObjectPropertyValue(ancestor::ObjectPropertyWithoutValue(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ObjectProperty, key)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.init;
    if let Some(field) = field {
        let other_field = &mut node.value;
        ctx.push_stack(Ancestor::ObjectPropertyInit(ancestor::ObjectPropertyWithoutInit(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ObjectProperty, value))
            },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_object_property(node, ctx);
}

pub(super) fn walk_property_key<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut PropertyKey<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_property_key(node, ctx);
    match node {
        PropertyKey::StaticIdentifier(node) => walk_identifier_name(traverser, node, ctx),
        PropertyKey::PrivateIdentifier(node) => walk_private_identifier(traverser, node, ctx),
        match_expression!(PropertyKey) => walk_expression(traverser, node.to_expression_mut(), ctx),
    }
    traverser.exit_property_key(node, ctx);
}

pub(super) fn walk_template_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TemplateLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_template_literal(node, ctx);
    let field = &mut node.quasis;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TemplateLiteralQuasis(ancestor::TemplateLiteralWithoutQuasis(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TemplateLiteral, span)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_template_element(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.expressions;
    let other_field = &mut node.quasis;
    ctx.push_stack(Ancestor::TemplateLiteralExpressions(
        ancestor::TemplateLiteralWithoutExpressions(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TemplateLiteral, quasis))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_expression(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_template_literal(node, ctx);
}

pub(super) fn walk_tagged_template_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TaggedTemplateExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_tagged_template_expression(node, ctx);
    let field = &mut node.tag;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TaggedTemplateExpressionTag(
        ancestor::TaggedTemplateExpressionWithoutTag(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TaggedTemplateExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.quasi;
    let other_field = &mut node.tag;
    ctx.push_stack(Ancestor::TaggedTemplateExpressionQuasi(
        ancestor::TaggedTemplateExpressionWithoutQuasi(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TaggedTemplateExpression, tag))
            },
            PhantomData,
        ),
    ));
    walk_template_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.quasi;
        ctx.push_stack(Ancestor::TaggedTemplateExpressionTypeParameters(
            ancestor::TaggedTemplateExpressionWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TaggedTemplateExpression, quasi))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_tagged_template_expression(node, ctx);
}

pub(super) fn walk_template_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TemplateElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_template_element(node, ctx);
    traverser.exit_template_element(node, ctx);
}

pub(super) fn walk_member_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut MemberExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_member_expression(node, ctx);
    match node {
        MemberExpression::ComputedMemberExpression(node) => {
            walk_computed_member_expression(traverser, node, ctx)
        }
        MemberExpression::StaticMemberExpression(node) => {
            walk_static_member_expression(traverser, node, ctx)
        }
        MemberExpression::PrivateFieldExpression(node) => {
            walk_private_field_expression(traverser, node, ctx)
        }
    }
    traverser.exit_member_expression(node, ctx);
}

pub(super) fn walk_computed_member_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ComputedMemberExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_computed_member_expression(node, ctx);
    let field = &mut node.object;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ComputedMemberExpressionObject(
        ancestor::ComputedMemberExpressionWithoutObject(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ComputedMemberExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.expression;
    let other_field = &mut node.object;
    ctx.push_stack(Ancestor::ComputedMemberExpressionExpression(
        ancestor::ComputedMemberExpressionWithoutExpression(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ComputedMemberExpression, object))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_computed_member_expression(node, ctx);
}

pub(super) fn walk_static_member_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut StaticMemberExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_static_member_expression(node, ctx);
    let field = &mut node.object;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::StaticMemberExpressionObject(
        ancestor::StaticMemberExpressionWithoutObject(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(StaticMemberExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.property;
    let other_field = &mut node.object;
    ctx.push_stack(Ancestor::StaticMemberExpressionProperty(
        ancestor::StaticMemberExpressionWithoutProperty(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(StaticMemberExpression, object))
            },
            PhantomData,
        ),
    ));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_static_member_expression(node, ctx);
}

pub(super) fn walk_private_field_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut PrivateFieldExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_private_field_expression(node, ctx);
    let field = &mut node.object;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::PrivateFieldExpressionObject(
        ancestor::PrivateFieldExpressionWithoutObject(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(PrivateFieldExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.field;
    let other_field = &mut node.object;
    ctx.push_stack(Ancestor::PrivateFieldExpressionField(
        ancestor::PrivateFieldExpressionWithoutField(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(PrivateFieldExpression, object))
            },
            PhantomData,
        ),
    ));
    walk_private_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_private_field_expression(node, ctx);
}

pub(super) fn walk_call_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut CallExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_call_expression(node, ctx);
    let field = &mut node.callee;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::CallExpressionCallee(ancestor::CallExpressionWithoutCallee(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(CallExpression, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.arguments;
    let other_field = &mut node.callee;
    ctx.push_stack(Ancestor::CallExpressionArguments(ancestor::CallExpressionWithoutArguments(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(CallExpression, callee)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_argument(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.optional;
        ctx.push_stack(Ancestor::CallExpressionTypeParameters(
            ancestor::CallExpressionWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(CallExpression, optional))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_call_expression(node, ctx);
}

pub(super) fn walk_new_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut NewExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_new_expression(node, ctx);
    let field = &mut node.callee;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::NewExpressionCallee(ancestor::NewExpressionWithoutCallee(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(NewExpression, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.arguments;
    let other_field = &mut node.callee;
    ctx.push_stack(Ancestor::NewExpressionArguments(ancestor::NewExpressionWithoutArguments(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(NewExpression, callee)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_argument(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.arguments;
        ctx.push_stack(Ancestor::NewExpressionTypeParameters(
            ancestor::NewExpressionWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(NewExpression, arguments))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_new_expression(node, ctx);
}

pub(super) fn walk_meta_property<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut MetaProperty<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_meta_property(node, ctx);
    let field = &mut node.meta;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::MetaPropertyMeta(ancestor::MetaPropertyWithoutMeta(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(MetaProperty, span)) },
        PhantomData,
    )));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.property;
    let other_field = &mut node.meta;
    ctx.push_stack(Ancestor::MetaPropertyProperty(ancestor::MetaPropertyWithoutProperty(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(MetaProperty, meta)) },
        PhantomData,
    )));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_meta_property(node, ctx);
}

pub(super) fn walk_spread_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut SpreadElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_spread_element(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::SpreadElementArgument(ancestor::SpreadElementWithoutArgument(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(SpreadElement, span)) },
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_spread_element(node, ctx);
}

pub(super) fn walk_argument<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Argument<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_argument(node, ctx);
    match node {
        Argument::SpreadElement(node) => walk_spread_element(traverser, node, ctx),
        match_expression!(Argument) => walk_expression(traverser, node.to_expression_mut(), ctx),
    }
    traverser.exit_argument(node, ctx);
}

pub(super) fn walk_update_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut UpdateExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_update_expression(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.prefix;
    ctx.push_stack(Ancestor::UpdateExpressionArgument(ancestor::UpdateExpressionWithoutArgument(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(UpdateExpression, prefix)) },
    )));
    walk_simple_assignment_target(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_update_expression(node, ctx);
}

pub(super) fn walk_unary_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut UnaryExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_unary_expression(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.operator;
    ctx.push_stack(Ancestor::UnaryExpressionArgument(ancestor::UnaryExpressionWithoutArgument(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(UnaryExpression, operator))
        },
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_unary_expression(node, ctx);
}

pub(super) fn walk_binary_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BinaryExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_binary_expression(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::BinaryExpressionLeft(ancestor::BinaryExpressionWithoutLeft(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(BinaryExpression, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.operator;
    ctx.push_stack(Ancestor::BinaryExpressionRight(ancestor::BinaryExpressionWithoutRight(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(BinaryExpression, operator))
        },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_binary_expression(node, ctx);
}

pub(super) fn walk_private_in_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut PrivateInExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_private_in_expression(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::PrivateInExpressionLeft(ancestor::PrivateInExpressionWithoutLeft(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(PrivateInExpression, span))
        },
        PhantomData,
    )));
    walk_private_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.operator;
    ctx.push_stack(Ancestor::PrivateInExpressionRight(ancestor::PrivateInExpressionWithoutRight(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(PrivateInExpression, operator))
        },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_private_in_expression(node, ctx);
}

pub(super) fn walk_logical_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut LogicalExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_logical_expression(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::LogicalExpressionLeft(ancestor::LogicalExpressionWithoutLeft(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(LogicalExpression, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.operator;
    ctx.push_stack(Ancestor::LogicalExpressionRight(ancestor::LogicalExpressionWithoutRight(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(LogicalExpression, operator))
        },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_logical_expression(node, ctx);
}

pub(super) fn walk_conditional_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ConditionalExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_conditional_expression(node, ctx);
    let field = &mut node.test;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ConditionalExpressionTest(
        ancestor::ConditionalExpressionWithoutTest(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ConditionalExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.consequent;
    let other_field = &mut node.test;
    ctx.push_stack(Ancestor::ConditionalExpressionConsequent(
        ancestor::ConditionalExpressionWithoutConsequent(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ConditionalExpression, test))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.alternate;
    let other_field = &mut node.consequent;
    ctx.push_stack(Ancestor::ConditionalExpressionAlternate(
        ancestor::ConditionalExpressionWithoutAlternate(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ConditionalExpression, consequent))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_conditional_expression(node, ctx);
}

pub(super) fn walk_assignment_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_expression(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.operator;
    ctx.push_stack(Ancestor::AssignmentExpressionLeft(ancestor::AssignmentExpressionWithoutLeft(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(AssignmentExpression, operator))
        },
        PhantomData,
    )));
    walk_assignment_target(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.left;
    ctx.push_stack(Ancestor::AssignmentExpressionRight(
        ancestor::AssignmentExpressionWithoutRight(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(AssignmentExpression, left))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_assignment_expression(node, ctx);
}

pub(super) fn walk_assignment_target<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTarget<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target(node, ctx);
    match node {
        match_simple_assignment_target!(AssignmentTarget) => {
            walk_simple_assignment_target(traverser, node.to_simple_assignment_target_mut(), ctx)
        }
        match_assignment_target_pattern!(AssignmentTarget) => {
            walk_assignment_target_pattern(traverser, node.to_assignment_target_pattern_mut(), ctx)
        }
    }
    traverser.exit_assignment_target(node, ctx);
}

pub(super) fn walk_simple_assignment_target<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut SimpleAssignmentTarget<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_simple_assignment_target(node, ctx);
    match node {
        SimpleAssignmentTarget::AssignmentTargetIdentifier(node) => {
            walk_identifier_reference(traverser, node, ctx)
        }
        SimpleAssignmentTarget::TSAsExpression(node) => walk_ts_as_expression(traverser, node, ctx),
        SimpleAssignmentTarget::TSSatisfiesExpression(node) => {
            walk_ts_satisfies_expression(traverser, node, ctx)
        }
        SimpleAssignmentTarget::TSNonNullExpression(node) => {
            walk_ts_non_null_expression(traverser, node, ctx)
        }
        SimpleAssignmentTarget::TSTypeAssertion(node) => {
            walk_ts_type_assertion(traverser, node, ctx)
        }
        match_member_expression!(SimpleAssignmentTarget) => {
            walk_member_expression(traverser, node.to_member_expression_mut(), ctx)
        }
    }
    traverser.exit_simple_assignment_target(node, ctx);
}

pub(super) fn walk_assignment_target_pattern<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetPattern<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_pattern(node, ctx);
    match node {
        AssignmentTargetPattern::ArrayAssignmentTarget(node) => {
            walk_array_assignment_target(traverser, node, ctx)
        }
        AssignmentTargetPattern::ObjectAssignmentTarget(node) => {
            walk_object_assignment_target(traverser, node, ctx)
        }
    }
    traverser.exit_assignment_target_pattern(node, ctx);
}

pub(super) fn walk_array_assignment_target<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ArrayAssignmentTarget<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_array_assignment_target(node, ctx);
    let field = &mut node.elements;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ArrayAssignmentTargetElements(
        ancestor::ArrayAssignmentTargetWithoutElements(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ArrayAssignmentTarget, span))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut().flatten() {
        walk_assignment_target_maybe_default(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.rest;
    if let Some(field) = field {
        let other_field = &mut node.elements;
        ctx.push_stack(Ancestor::ArrayAssignmentTargetRest(
            ancestor::ArrayAssignmentTargetWithoutRest(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ArrayAssignmentTarget, elements))
                },
                PhantomData,
            ),
        ));
        walk_assignment_target_rest(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_array_assignment_target(node, ctx);
}

pub(super) fn walk_object_assignment_target<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ObjectAssignmentTarget<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_object_assignment_target(node, ctx);
    let field = &mut node.properties;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ObjectAssignmentTargetProperties(
        ancestor::ObjectAssignmentTargetWithoutProperties(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ObjectAssignmentTarget, span))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_assignment_target_property(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.rest;
    if let Some(field) = field {
        let other_field = &mut node.properties;
        ctx.push_stack(Ancestor::ObjectAssignmentTargetRest(
            ancestor::ObjectAssignmentTargetWithoutRest(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ObjectAssignmentTarget, properties))
                },
                PhantomData,
            ),
        ));
        walk_assignment_target_rest(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_object_assignment_target(node, ctx);
}

pub(super) fn walk_assignment_target_rest<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetRest<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_rest(node, ctx);
    let field = &mut node.target;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AssignmentTargetRestTarget(
        ancestor::AssignmentTargetRestWithoutTarget(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(AssignmentTargetRest, span))
        }),
    ));
    walk_assignment_target(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_assignment_target_rest(node, ctx);
}

pub(super) fn walk_assignment_target_maybe_default<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetMaybeDefault<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_maybe_default(node, ctx);
    match node {
        AssignmentTargetMaybeDefault::AssignmentTargetWithDefault(node) => {
            walk_assignment_target_with_default(traverser, node, ctx)
        }
        match_assignment_target!(AssignmentTargetMaybeDefault) => {
            walk_assignment_target(traverser, node.to_assignment_target_mut(), ctx)
        }
    }
    traverser.exit_assignment_target_maybe_default(node, ctx);
}

pub(super) fn walk_assignment_target_with_default<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetWithDefault<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_with_default(node, ctx);
    let field = &mut node.binding;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AssignmentTargetWithDefaultBinding(
        ancestor::AssignmentTargetWithDefaultWithoutBinding(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(AssignmentTargetWithDefault, span))
            },
            PhantomData,
        ),
    ));
    walk_assignment_target(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.init;
    let other_field = &mut node.binding;
    ctx.push_stack(Ancestor::AssignmentTargetWithDefaultInit(
        ancestor::AssignmentTargetWithDefaultWithoutInit(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(AssignmentTargetWithDefault, binding))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_assignment_target_with_default(node, ctx);
}

pub(super) fn walk_assignment_target_property<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetProperty<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_property(node, ctx);
    match node {
        AssignmentTargetProperty::AssignmentTargetPropertyIdentifier(node) => {
            walk_assignment_target_property_identifier(traverser, node, ctx)
        }
        AssignmentTargetProperty::AssignmentTargetPropertyProperty(node) => {
            walk_assignment_target_property_property(traverser, node, ctx)
        }
    }
    traverser.exit_assignment_target_property(node, ctx);
}

pub(super) fn walk_assignment_target_property_identifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetPropertyIdentifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_property_identifier(node, ctx);
    let field = &mut node.binding;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AssignmentTargetPropertyIdentifierBinding(
        ancestor::AssignmentTargetPropertyIdentifierWithoutBinding(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(AssignmentTargetPropertyIdentifier, span))
            },
            PhantomData,
        ),
    ));
    walk_identifier_reference(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.init;
    if let Some(field) = field {
        let other_field = &mut node.binding;
        ctx.push_stack(Ancestor::AssignmentTargetPropertyIdentifierInit(
            ancestor::AssignmentTargetPropertyIdentifierWithoutInit(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(AssignmentTargetPropertyIdentifier, binding))
                },
                PhantomData,
            ),
        ));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_assignment_target_property_identifier(node, ctx);
}

pub(super) fn walk_assignment_target_property_property<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentTargetPropertyProperty<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_target_property_property(node, ctx);
    let field = &mut node.name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AssignmentTargetPropertyPropertyName(
        ancestor::AssignmentTargetPropertyPropertyWithoutName(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(AssignmentTargetPropertyProperty, span))
            },
            PhantomData,
        ),
    ));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.binding;
    let other_field = &mut node.name;
    ctx.push_stack(Ancestor::AssignmentTargetPropertyPropertyBinding(
        ancestor::AssignmentTargetPropertyPropertyWithoutBinding(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(AssignmentTargetPropertyProperty, name))
            },
            PhantomData,
        ),
    ));
    walk_assignment_target_maybe_default(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_assignment_target_property_property(node, ctx);
}

pub(super) fn walk_sequence_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut SequenceExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_sequence_expression(node, ctx);
    let field = &mut node.expressions;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::SequenceExpressionExpressions(
        ancestor::SequenceExpressionWithoutExpressions(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(SequenceExpression, span))
        }),
    ));
    for field in field.iter_mut() {
        walk_expression(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_sequence_expression(node, ctx);
}

pub(super) fn walk_super<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Super,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_super(node, ctx);
    traverser.exit_super(node, ctx);
}

pub(super) fn walk_await_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AwaitExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_await_expression(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AwaitExpressionArgument(ancestor::AwaitExpressionWithoutArgument(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(AwaitExpression, span)) },
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_await_expression(node, ctx);
}

pub(super) fn walk_chain_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ChainExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_chain_expression(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ChainExpressionExpression(
        ancestor::ChainExpressionWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ChainExpression, span))
        }),
    ));
    walk_chain_element(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_chain_expression(node, ctx);
}

pub(super) fn walk_chain_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ChainElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_chain_element(node, ctx);
    match node {
        ChainElement::CallExpression(node) => walk_call_expression(traverser, node, ctx),
        match_member_expression!(ChainElement) => {
            walk_member_expression(traverser, node.to_member_expression_mut(), ctx)
        }
    }
    traverser.exit_chain_element(node, ctx);
}

pub(super) fn walk_parenthesized_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ParenthesizedExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_parenthesized_expression(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ParenthesizedExpressionExpression(
        ancestor::ParenthesizedExpressionWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ParenthesizedExpression, span))
        }),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_parenthesized_expression(node, ctx);
}

pub(super) fn walk_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Statement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_statement(node, ctx);
    match node {
        Statement::BlockStatement(node) => walk_block_statement(traverser, node, ctx),
        Statement::BreakStatement(node) => walk_break_statement(traverser, node, ctx),
        Statement::ContinueStatement(node) => walk_continue_statement(traverser, node, ctx),
        Statement::DebuggerStatement(node) => walk_debugger_statement(traverser, node, ctx),
        Statement::DoWhileStatement(node) => walk_do_while_statement(traverser, node, ctx),
        Statement::EmptyStatement(node) => walk_empty_statement(traverser, node, ctx),
        Statement::ExpressionStatement(node) => walk_expression_statement(traverser, node, ctx),
        Statement::ForInStatement(node) => walk_for_in_statement(traverser, node, ctx),
        Statement::ForOfStatement(node) => walk_for_of_statement(traverser, node, ctx),
        Statement::ForStatement(node) => walk_for_statement(traverser, node, ctx),
        Statement::IfStatement(node) => walk_if_statement(traverser, node, ctx),
        Statement::LabeledStatement(node) => walk_labeled_statement(traverser, node, ctx),
        Statement::ReturnStatement(node) => walk_return_statement(traverser, node, ctx),
        Statement::SwitchStatement(node) => walk_switch_statement(traverser, node, ctx),
        Statement::ThrowStatement(node) => walk_throw_statement(traverser, node, ctx),
        Statement::TryStatement(node) => walk_try_statement(traverser, node, ctx),
        Statement::WhileStatement(node) => walk_while_statement(traverser, node, ctx),
        Statement::WithStatement(node) => walk_with_statement(traverser, node, ctx),
        match_declaration!(Statement) => {
            walk_declaration(traverser, node.to_declaration_mut(), ctx)
        }
        match_module_declaration!(Statement) => {
            walk_module_declaration(traverser, node.to_module_declaration_mut(), ctx)
        }
    }
    traverser.exit_statement(node, ctx);
}

pub(super) fn walk_directive<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Directive<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_directive(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::DirectiveExpression(ancestor::DirectiveWithoutExpression(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Directive, span)) },
        PhantomData,
    )));
    walk_string_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_directive(node, ctx);
}

pub(super) fn walk_hashbang<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Hashbang<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_hashbang(node, ctx);
    traverser.exit_hashbang(node, ctx);
}

pub(super) fn walk_block_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BlockStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_block_statement(node, ctx);
    let field = &mut node.body;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::BlockStatementBody(ancestor::BlockStatementWithoutBody(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(BlockStatement, span))
    })));
    walk_statements(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_block_statement(node, ctx);
}

pub(super) fn walk_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Declaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_declaration(node, ctx);
    match node {
        Declaration::VariableDeclaration(node) => walk_variable_declaration(traverser, node, ctx),
        Declaration::FunctionDeclaration(node) => walk_function(traverser, node, ctx),
        Declaration::ClassDeclaration(node) => walk_class(traverser, node, ctx),
        Declaration::UsingDeclaration(node) => walk_using_declaration(traverser, node, ctx),
        Declaration::TSTypeAliasDeclaration(node) => {
            walk_ts_type_alias_declaration(traverser, node, ctx)
        }
        Declaration::TSInterfaceDeclaration(node) => {
            walk_ts_interface_declaration(traverser, node, ctx)
        }
        Declaration::TSEnumDeclaration(node) => walk_ts_enum_declaration(traverser, node, ctx),
        Declaration::TSModuleDeclaration(node) => walk_ts_module_declaration(traverser, node, ctx),
        Declaration::TSImportEqualsDeclaration(node) => {
            walk_ts_import_equals_declaration(traverser, node, ctx)
        }
    }
    traverser.exit_declaration(node, ctx);
}

pub(super) fn walk_variable_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut VariableDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_variable_declaration(node, ctx);
    let field = &mut node.declarations;
    let other_field = &mut node.kind;
    ctx.push_stack(Ancestor::VariableDeclarationDeclarations(
        ancestor::VariableDeclarationWithoutDeclarations(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(VariableDeclaration, kind))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_variable_declarator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_variable_declaration(node, ctx);
}

pub(super) fn walk_variable_declarator<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut VariableDeclarator<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_variable_declarator(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::VariableDeclaratorId(ancestor::VariableDeclaratorWithoutId(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(VariableDeclarator, span)) },
        PhantomData,
    )));
    walk_binding_pattern(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.init;
    if let Some(field) = field {
        let other_field = &mut node.id;
        ctx.push_stack(Ancestor::VariableDeclaratorInit(ancestor::VariableDeclaratorWithoutInit(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(VariableDeclarator, id))
            },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_variable_declarator(node, ctx);
}

pub(super) fn walk_using_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut UsingDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_using_declaration(node, ctx);
    let field = &mut node.declarations;
    let other_field = &mut node.is_await;
    ctx.push_stack(Ancestor::UsingDeclarationDeclarations(
        ancestor::UsingDeclarationWithoutDeclarations(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(UsingDeclaration, is_await))
        }),
    ));
    for field in field.iter_mut() {
        walk_variable_declarator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_using_declaration(node, ctx);
}

pub(super) fn walk_empty_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut EmptyStatement,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_empty_statement(node, ctx);
    traverser.exit_empty_statement(node, ctx);
}

pub(super) fn walk_expression_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ExpressionStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_expression_statement(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ExpressionStatementExpression(
        ancestor::ExpressionStatementWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ExpressionStatement, span))
        }),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_expression_statement(node, ctx);
}

pub(super) fn walk_if_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut IfStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_if_statement(node, ctx);
    let field = &mut node.test;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::IfStatementTest(ancestor::IfStatementWithoutTest(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(IfStatement, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.consequent;
    let other_field = &mut node.test;
    ctx.push_stack(Ancestor::IfStatementConsequent(ancestor::IfStatementWithoutConsequent(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(IfStatement, test)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.alternate;
    if let Some(field) = field {
        let other_field = &mut node.consequent;
        ctx.push_stack(Ancestor::IfStatementAlternate(ancestor::IfStatementWithoutAlternate(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(IfStatement, consequent))
            },
            PhantomData,
        )));
        walk_statement(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_if_statement(node, ctx);
}

pub(super) fn walk_do_while_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut DoWhileStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_do_while_statement(node, ctx);
    let field = &mut node.body;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::DoWhileStatementBody(ancestor::DoWhileStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(DoWhileStatement, span)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.test;
    let other_field = &mut node.body;
    ctx.push_stack(Ancestor::DoWhileStatementTest(ancestor::DoWhileStatementWithoutTest(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(DoWhileStatement, body)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_do_while_statement(node, ctx);
}

pub(super) fn walk_while_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut WhileStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_while_statement(node, ctx);
    let field = &mut node.test;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::WhileStatementTest(ancestor::WhileStatementWithoutTest(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(WhileStatement, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.test;
    ctx.push_stack(Ancestor::WhileStatementBody(ancestor::WhileStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(WhileStatement, test)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_while_statement(node, ctx);
}

pub(super) fn walk_for_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ForStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_for_statement(node, ctx);
    let field = &mut node.init;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ForStatementInit(ancestor::ForStatementWithoutInit(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForStatement, span)) },
            PhantomData,
        )));
        walk_for_statement_init(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.test;
    if let Some(field) = field {
        let other_field = &mut node.init;
        ctx.push_stack(Ancestor::ForStatementTest(ancestor::ForStatementWithoutTest(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForStatement, init)) },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.update;
    if let Some(field) = field {
        let other_field = &mut node.test;
        ctx.push_stack(Ancestor::ForStatementUpdate(ancestor::ForStatementWithoutUpdate(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForStatement, test)) },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.body;
    let other_field = &mut node.update;
    ctx.push_stack(Ancestor::ForStatementBody(ancestor::ForStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForStatement, update)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_for_statement(node, ctx);
}

pub(super) fn walk_for_statement_init<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ForStatementInit<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_for_statement_init(node, ctx);
    match node {
        ForStatementInit::VariableDeclaration(node) => {
            walk_variable_declaration(traverser, node, ctx)
        }
        ForStatementInit::UsingDeclaration(node) => walk_using_declaration(traverser, node, ctx),
        match_expression!(ForStatementInit) => {
            walk_expression(traverser, node.to_expression_mut(), ctx)
        }
    }
    traverser.exit_for_statement_init(node, ctx);
}

pub(super) fn walk_for_in_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ForInStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_for_in_statement(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ForInStatementLeft(ancestor::ForInStatementWithoutLeft(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForInStatement, span)) },
        PhantomData,
    )));
    walk_for_statement_left(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.left;
    ctx.push_stack(Ancestor::ForInStatementRight(ancestor::ForInStatementWithoutRight(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForInStatement, left)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.right;
    ctx.push_stack(Ancestor::ForInStatementBody(ancestor::ForInStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForInStatement, right)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_for_in_statement(node, ctx);
}

pub(super) fn walk_for_of_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ForOfStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_for_of_statement(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.r#await;
    ctx.push_stack(Ancestor::ForOfStatementLeft(ancestor::ForOfStatementWithoutLeft(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForOfStatement, r#await)) },
        PhantomData,
    )));
    walk_for_statement_left(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.left;
    ctx.push_stack(Ancestor::ForOfStatementRight(ancestor::ForOfStatementWithoutRight(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForOfStatement, left)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.right;
    ctx.push_stack(Ancestor::ForOfStatementBody(ancestor::ForOfStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ForOfStatement, right)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_for_of_statement(node, ctx);
}

pub(super) fn walk_for_statement_left<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ForStatementLeft<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_for_statement_left(node, ctx);
    match node {
        ForStatementLeft::VariableDeclaration(node) => {
            walk_variable_declaration(traverser, node, ctx)
        }
        ForStatementLeft::UsingDeclaration(node) => walk_using_declaration(traverser, node, ctx),
        match_assignment_target!(ForStatementLeft) => {
            walk_assignment_target(traverser, node.to_assignment_target_mut(), ctx)
        }
    }
    traverser.exit_for_statement_left(node, ctx);
}

pub(super) fn walk_continue_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ContinueStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_continue_statement(node, ctx);
    let field = &mut node.label;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ContinueStatementLabel(ancestor::ContinueStatementWithoutLabel(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ContinueStatement, span))
            },
        )));
        walk_label_identifier(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_continue_statement(node, ctx);
}

pub(super) fn walk_break_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BreakStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_break_statement(node, ctx);
    let field = &mut node.label;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::BreakStatementLabel(ancestor::BreakStatementWithoutLabel(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(BreakStatement, span)) },
        )));
        walk_label_identifier(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_break_statement(node, ctx);
}

pub(super) fn walk_return_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ReturnStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_return_statement(node, ctx);
    let field = &mut node.argument;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ReturnStatementArgument(
            ancestor::ReturnStatementWithoutArgument(unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ReturnStatement, span))
            }),
        ));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_return_statement(node, ctx);
}

pub(super) fn walk_with_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut WithStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_with_statement(node, ctx);
    let field = &mut node.object;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::WithStatementObject(ancestor::WithStatementWithoutObject(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(WithStatement, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.object;
    ctx.push_stack(Ancestor::WithStatementBody(ancestor::WithStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(WithStatement, object)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_with_statement(node, ctx);
}

pub(super) fn walk_switch_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut SwitchStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_switch_statement(node, ctx);
    let field = &mut node.discriminant;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::SwitchStatementDiscriminant(
        ancestor::SwitchStatementWithoutDiscriminant(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(SwitchStatement, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.cases;
    let other_field = &mut node.discriminant;
    ctx.push_stack(Ancestor::SwitchStatementCases(ancestor::SwitchStatementWithoutCases(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(SwitchStatement, discriminant))
        },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_switch_case(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_switch_statement(node, ctx);
}

pub(super) fn walk_switch_case<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut SwitchCase<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_switch_case(node, ctx);
    let field = &mut node.test;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::SwitchCaseTest(ancestor::SwitchCaseWithoutTest(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(SwitchCase, span)) },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.consequent;
    let other_field = &mut node.test;
    ctx.push_stack(Ancestor::SwitchCaseConsequent(ancestor::SwitchCaseWithoutConsequent(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(SwitchCase, test)) },
        PhantomData,
    )));
    walk_statements(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_switch_case(node, ctx);
}

pub(super) fn walk_labeled_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut LabeledStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_labeled_statement(node, ctx);
    let field = &mut node.label;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::LabeledStatementLabel(ancestor::LabeledStatementWithoutLabel(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(LabeledStatement, span)) },
        PhantomData,
    )));
    walk_label_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.label;
    ctx.push_stack(Ancestor::LabeledStatementBody(ancestor::LabeledStatementWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(LabeledStatement, label)) },
        PhantomData,
    )));
    walk_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_labeled_statement(node, ctx);
}

pub(super) fn walk_throw_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ThrowStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_throw_statement(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ThrowStatementArgument(ancestor::ThrowStatementWithoutArgument(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ThrowStatement, span)) },
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_throw_statement(node, ctx);
}

pub(super) fn walk_try_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TryStatement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_try_statement(node, ctx);
    let field = &mut node.block;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TryStatementBlock(ancestor::TryStatementWithoutBlock(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TryStatement, span)) },
        PhantomData,
    )));
    walk_block_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.handler;
    if let Some(field) = field {
        let other_field = &mut node.block;
        ctx.push_stack(Ancestor::TryStatementHandler(ancestor::TryStatementWithoutHandler(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TryStatement, block)) },
            PhantomData,
        )));
        walk_catch_clause(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.finalizer;
    if let Some(field) = field {
        let other_field = &mut node.handler;
        ctx.push_stack(Ancestor::TryStatementFinalizer(ancestor::TryStatementWithoutFinalizer(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TryStatement, handler))
            },
            PhantomData,
        )));
        walk_block_statement(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_try_statement(node, ctx);
}

pub(super) fn walk_catch_clause<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut CatchClause<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_catch_clause(node, ctx);
    let field = &mut node.param;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::CatchClauseParam(ancestor::CatchClauseWithoutParam(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(CatchClause, span)) },
            PhantomData,
        )));
        walk_catch_parameter(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.body;
    let other_field = &mut node.param;
    ctx.push_stack(Ancestor::CatchClauseBody(ancestor::CatchClauseWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(CatchClause, param)) },
        PhantomData,
    )));
    walk_block_statement(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_catch_clause(node, ctx);
}

pub(super) fn walk_catch_parameter<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut CatchParameter<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_catch_parameter(node, ctx);
    let field = &mut node.pattern;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::CatchParameterPattern(ancestor::CatchParameterWithoutPattern(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(CatchParameter, span)) },
    )));
    walk_binding_pattern(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_catch_parameter(node, ctx);
}

pub(super) fn walk_debugger_statement<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut DebuggerStatement,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_debugger_statement(node, ctx);
    traverser.exit_debugger_statement(node, ctx);
}

pub(super) fn walk_binding_pattern<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BindingPattern<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_binding_pattern(node, ctx);
    let field = &mut node.kind;
    let other_field = &mut node.type_annotation;
    ctx.push_stack(Ancestor::BindingPatternKind(ancestor::BindingPatternWithoutKind(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(BindingPattern, type_annotation))
        },
        PhantomData,
    )));
    walk_binding_pattern_kind(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    if let Some(field) = field {
        let other_field = &mut node.kind;
        ctx.push_stack(Ancestor::BindingPatternTypeAnnotation(
            ancestor::BindingPatternWithoutTypeAnnotation(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(BindingPattern, kind))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_binding_pattern(node, ctx);
}

pub(super) fn walk_binding_pattern_kind<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BindingPatternKind<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_binding_pattern_kind(node, ctx);
    match node {
        BindingPatternKind::BindingIdentifier(node) => {
            walk_binding_identifier(traverser, node, ctx)
        }
        BindingPatternKind::ObjectPattern(node) => walk_object_pattern(traverser, node, ctx),
        BindingPatternKind::ArrayPattern(node) => walk_array_pattern(traverser, node, ctx),
        BindingPatternKind::AssignmentPattern(node) => {
            walk_assignment_pattern(traverser, node, ctx)
        }
    }
    traverser.exit_binding_pattern_kind(node, ctx);
}

pub(super) fn walk_assignment_pattern<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AssignmentPattern<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_assignment_pattern(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AssignmentPatternLeft(ancestor::AssignmentPatternWithoutLeft(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(AssignmentPattern, span)) },
        PhantomData,
    )));
    walk_binding_pattern(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.left;
    ctx.push_stack(Ancestor::AssignmentPatternRight(ancestor::AssignmentPatternWithoutRight(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(AssignmentPattern, left)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_assignment_pattern(node, ctx);
}

pub(super) fn walk_object_pattern<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ObjectPattern<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_object_pattern(node, ctx);
    let field = &mut node.properties;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ObjectPatternProperties(ancestor::ObjectPatternWithoutProperties(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ObjectPattern, span)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_binding_property(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.rest;
    if let Some(field) = field {
        let other_field = &mut node.properties;
        ctx.push_stack(Ancestor::ObjectPatternRest(ancestor::ObjectPatternWithoutRest(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ObjectPattern, properties))
            },
            PhantomData,
        )));
        walk_binding_rest_element(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_object_pattern(node, ctx);
}

pub(super) fn walk_binding_property<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BindingProperty<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_binding_property(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::BindingPropertyKey(ancestor::BindingPropertyWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(BindingProperty, span)) },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    let other_field = &mut node.key;
    ctx.push_stack(Ancestor::BindingPropertyValue(ancestor::BindingPropertyWithoutValue(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(BindingProperty, key)) },
        PhantomData,
    )));
    walk_binding_pattern(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_binding_property(node, ctx);
}

pub(super) fn walk_array_pattern<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ArrayPattern<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_array_pattern(node, ctx);
    let field = &mut node.elements;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ArrayPatternElements(ancestor::ArrayPatternWithoutElements(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ArrayPattern, span)) },
        PhantomData,
    )));
    for field in field.iter_mut().flatten() {
        walk_binding_pattern(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.rest;
    if let Some(field) = field {
        let other_field = &mut node.elements;
        ctx.push_stack(Ancestor::ArrayPatternRest(ancestor::ArrayPatternWithoutRest(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ArrayPattern, elements))
            },
            PhantomData,
        )));
        walk_binding_rest_element(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_array_pattern(node, ctx);
}

pub(super) fn walk_binding_rest_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BindingRestElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_binding_rest_element(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::BindingRestElementArgument(
        ancestor::BindingRestElementWithoutArgument(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(BindingRestElement, span))
        }),
    ));
    walk_binding_pattern(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_binding_rest_element(node, ctx);
}

pub(super) fn walk_function<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Function<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_function(node, ctx);
    let field = &mut node.id;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::FunctionId(ancestor::FunctionWithoutId(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Function, span)) },
            PhantomData,
        )));
        walk_binding_identifier(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.this_param;
    if let Some(field) = field {
        let other_field = &mut node.r#async;
        ctx.push_stack(Ancestor::FunctionThisParam(ancestor::FunctionWithoutThisParam(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Function, r#async)) },
            PhantomData,
        )));
        walk_ts_this_parameter(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.params;
    let other_field = &mut node.this_param;
    ctx.push_stack(Ancestor::FunctionParams(ancestor::FunctionWithoutParams(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Function, this_param)) },
        PhantomData,
    )));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    if let Some(field) = field {
        let other_field = &mut node.params;
        ctx.push_stack(Ancestor::FunctionBody(ancestor::FunctionWithoutBody(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Function, params)) },
            PhantomData,
        )));
        walk_function_body(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.body;
        ctx.push_stack(Ancestor::FunctionTypeParameters(ancestor::FunctionWithoutTypeParameters(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Function, body)) },
            PhantomData,
        )));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.return_type;
    if let Some(field) = field {
        let other_field = &mut node.type_parameters;
        ctx.push_stack(Ancestor::FunctionReturnType(ancestor::FunctionWithoutReturnType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(Function, type_parameters))
            },
            PhantomData,
        )));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_function(node, ctx);
}

pub(super) fn walk_formal_parameters<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut FormalParameters<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_formal_parameters(node, ctx);
    let field = &mut node.items;
    let other_field = &mut node.kind;
    ctx.push_stack(Ancestor::FormalParametersItems(ancestor::FormalParametersWithoutItems(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(FormalParameters, kind)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_formal_parameter(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.rest;
    if let Some(field) = field {
        let other_field = &mut node.items;
        ctx.push_stack(Ancestor::FormalParametersRest(ancestor::FormalParametersWithoutRest(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(FormalParameters, items))
            },
            PhantomData,
        )));
        walk_binding_rest_element(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_formal_parameters(node, ctx);
}

pub(super) fn walk_formal_parameter<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut FormalParameter<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_formal_parameter(node, ctx);
    let field = &mut node.pattern;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::FormalParameterPattern(ancestor::FormalParameterWithoutPattern(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(FormalParameter, span)) },
        PhantomData,
    )));
    walk_binding_pattern(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.decorators;
    let other_field = &mut node.r#override;
    ctx.push_stack(Ancestor::FormalParameterDecorators(
        ancestor::FormalParameterWithoutDecorators(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(FormalParameter, r#override))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_decorator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_formal_parameter(node, ctx);
}

pub(super) fn walk_function_body<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut FunctionBody<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_function_body(node, ctx);
    let field = &mut node.directives;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::FunctionBodyDirectives(ancestor::FunctionBodyWithoutDirectives(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(FunctionBody, span)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_directive(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.statements;
    let other_field = &mut node.directives;
    ctx.push_stack(Ancestor::FunctionBodyStatements(ancestor::FunctionBodyWithoutStatements(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(FunctionBody, directives)) },
        PhantomData,
    )));
    walk_statements(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_function_body(node, ctx);
}

pub(super) fn walk_arrow_function_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ArrowFunctionExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_arrow_function_expression(node, ctx);
    let field = &mut node.params;
    let other_field = &mut node.r#async;
    ctx.push_stack(Ancestor::ArrowFunctionExpressionParams(
        ancestor::ArrowFunctionExpressionWithoutParams(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ArrowFunctionExpression, r#async))
            },
            PhantomData,
        ),
    ));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.params;
    ctx.push_stack(Ancestor::ArrowFunctionExpressionBody(
        ancestor::ArrowFunctionExpressionWithoutBody(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ArrowFunctionExpression, params))
            },
            PhantomData,
        ),
    ));
    walk_function_body(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.body;
        ctx.push_stack(Ancestor::ArrowFunctionExpressionTypeParameters(
            ancestor::ArrowFunctionExpressionWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ArrowFunctionExpression, body))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.return_type;
    if let Some(field) = field {
        let other_field = &mut node.type_parameters;
        ctx.push_stack(Ancestor::ArrowFunctionExpressionReturnType(
            ancestor::ArrowFunctionExpressionWithoutReturnType(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ArrowFunctionExpression, type_parameters))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_arrow_function_expression(node, ctx);
}

pub(super) fn walk_yield_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut YieldExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_yield_expression(node, ctx);
    let field = &mut node.argument;
    if let Some(field) = field {
        let other_field = &mut node.delegate;
        ctx.push_stack(Ancestor::YieldExpressionArgument(
            ancestor::YieldExpressionWithoutArgument(unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(YieldExpression, delegate))
            }),
        ));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_yield_expression(node, ctx);
}

pub(super) fn walk_class<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Class<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_class(node, ctx);
    let field = &mut node.id;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ClassId(ancestor::ClassWithoutId(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Class, span)) },
            PhantomData,
        )));
        walk_binding_identifier(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.super_class;
    if let Some(field) = field {
        let other_field = &mut node.id;
        ctx.push_stack(Ancestor::ClassSuperClass(ancestor::ClassWithoutSuperClass(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Class, id)) },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.body;
    let other_field = &mut node.super_class;
    ctx.push_stack(Ancestor::ClassBody(ancestor::ClassWithoutBody(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Class, super_class)) },
        PhantomData,
    )));
    walk_class_body(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.body;
        ctx.push_stack(Ancestor::ClassTypeParameters(ancestor::ClassWithoutTypeParameters(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Class, body)) },
            PhantomData,
        )));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.super_type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.type_parameters;
        ctx.push_stack(Ancestor::ClassSuperTypeParameters(
            ancestor::ClassWithoutSuperTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(Class, type_parameters))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.implements;
    if let Some(field) = field {
        let other_field = &mut node.super_type_parameters;
        ctx.push_stack(Ancestor::ClassImplements(ancestor::ClassWithoutImplements(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(Class, super_type_parameters))
            },
            PhantomData,
        )));
        for field in field.iter_mut() {
            walk_ts_class_implements(traverser, field, ctx);
        }
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.decorators;
    let other_field = &mut node.implements;
    ctx.push_stack(Ancestor::ClassDecorators(ancestor::ClassWithoutDecorators(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(Class, implements)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_decorator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_class(node, ctx);
}

pub(super) fn walk_class_body<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ClassBody<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_class_body(node, ctx);
    let field = &mut node.body;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ClassBodyBody(ancestor::ClassBodyWithoutBody(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(ClassBody, span))
    })));
    for field in field.iter_mut() {
        walk_class_element(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_class_body(node, ctx);
}

pub(super) fn walk_class_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ClassElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_class_element(node, ctx);
    match node {
        ClassElement::StaticBlock(node) => walk_static_block(traverser, node, ctx),
        ClassElement::MethodDefinition(node) => walk_method_definition(traverser, node, ctx),
        ClassElement::PropertyDefinition(node) => walk_property_definition(traverser, node, ctx),
        ClassElement::AccessorProperty(node) => walk_accessor_property(traverser, node, ctx),
        ClassElement::TSIndexSignature(node) => walk_ts_index_signature(traverser, node, ctx),
    }
    traverser.exit_class_element(node, ctx);
}

pub(super) fn walk_method_definition<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut MethodDefinition<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_method_definition(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::MethodDefinitionKey(ancestor::MethodDefinitionWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(MethodDefinition, span)) },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    let other_field = &mut node.key;
    ctx.push_stack(Ancestor::MethodDefinitionValue(ancestor::MethodDefinitionWithoutValue(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(MethodDefinition, key)) },
        PhantomData,
    )));
    walk_function(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.decorators;
    let other_field = &mut node.accessibility;
    ctx.push_stack(Ancestor::MethodDefinitionDecorators(
        ancestor::MethodDefinitionWithoutDecorators(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(MethodDefinition, accessibility))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_decorator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_method_definition(node, ctx);
}

pub(super) fn walk_property_definition<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut PropertyDefinition<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_property_definition(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::PropertyDefinitionKey(ancestor::PropertyDefinitionWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(PropertyDefinition, span)) },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    if let Some(field) = field {
        let other_field = &mut node.key;
        ctx.push_stack(Ancestor::PropertyDefinitionValue(
            ancestor::PropertyDefinitionWithoutValue(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(PropertyDefinition, key))
                },
                PhantomData,
            ),
        ));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_annotation;
    if let Some(field) = field {
        let other_field = &mut node.readonly;
        ctx.push_stack(Ancestor::PropertyDefinitionTypeAnnotation(
            ancestor::PropertyDefinitionWithoutTypeAnnotation(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(PropertyDefinition, readonly))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.decorators;
    let other_field = &mut node.accessibility;
    ctx.push_stack(Ancestor::PropertyDefinitionDecorators(
        ancestor::PropertyDefinitionWithoutDecorators(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(PropertyDefinition, accessibility))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_decorator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_property_definition(node, ctx);
}

pub(super) fn walk_private_identifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut PrivateIdentifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_private_identifier(node, ctx);
    traverser.exit_private_identifier(node, ctx);
}

pub(super) fn walk_static_block<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut StaticBlock<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_static_block(node, ctx);
    let field = &mut node.body;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::StaticBlockBody(ancestor::StaticBlockWithoutBody(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(StaticBlock, span))
    })));
    walk_statements(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_static_block(node, ctx);
}

pub(super) fn walk_module_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ModuleDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_module_declaration(node, ctx);
    match node {
        ModuleDeclaration::ImportDeclaration(node) => walk_import_declaration(traverser, node, ctx),
        ModuleDeclaration::ExportAllDeclaration(node) => {
            walk_export_all_declaration(traverser, node, ctx)
        }
        ModuleDeclaration::ExportDefaultDeclaration(node) => {
            walk_export_default_declaration(traverser, node, ctx)
        }
        ModuleDeclaration::ExportNamedDeclaration(node) => {
            walk_export_named_declaration(traverser, node, ctx)
        }
        ModuleDeclaration::TSExportAssignment(node) => {
            walk_ts_export_assignment(traverser, node, ctx)
        }
        ModuleDeclaration::TSNamespaceExportDeclaration(node) => {
            walk_ts_namespace_export_declaration(traverser, node, ctx)
        }
    }
    traverser.exit_module_declaration(node, ctx);
}

pub(super) fn walk_accessor_property<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut AccessorProperty<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_accessor_property(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::AccessorPropertyKey(ancestor::AccessorPropertyWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(AccessorProperty, span)) },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    if let Some(field) = field {
        let other_field = &mut node.key;
        ctx.push_stack(Ancestor::AccessorPropertyValue(ancestor::AccessorPropertyWithoutValue(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(AccessorProperty, key))
            },
            PhantomData,
        )));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.decorators;
    let other_field = &mut node.r#static;
    ctx.push_stack(Ancestor::AccessorPropertyDecorators(
        ancestor::AccessorPropertyWithoutDecorators(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(AccessorProperty, r#static))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_decorator(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_accessor_property(node, ctx);
}

pub(super) fn walk_import_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_expression(node, ctx);
    let field = &mut node.source;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ImportExpressionSource(ancestor::ImportExpressionWithoutSource(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ImportExpression, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.arguments;
    let other_field = &mut node.source;
    ctx.push_stack(Ancestor::ImportExpressionArguments(
        ancestor::ImportExpressionWithoutArguments(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(ImportExpression, source))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_expression(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_import_expression(node, ctx);
}

pub(super) fn walk_import_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_declaration(node, ctx);
    let field = &mut node.specifiers;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ImportDeclarationSpecifiers(
            ancestor::ImportDeclarationWithoutSpecifiers(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(ImportDeclaration, span))
                },
                PhantomData,
            ),
        ));
        for field in field.iter_mut() {
            walk_import_declaration_specifier(traverser, field, ctx);
        }
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.source;
    let other_field = &mut node.specifiers;
    ctx.push_stack(Ancestor::ImportDeclarationSource(ancestor::ImportDeclarationWithoutSource(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ImportDeclaration, specifiers))
        },
        PhantomData,
    )));
    walk_string_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.with_clause;
    if let Some(field) = field {
        let other_field = &mut node.source;
        ctx.push_stack(Ancestor::ImportDeclarationWithClause(
            ancestor::ImportDeclarationWithoutWithClause(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ImportDeclaration, source))
                },
                PhantomData,
            ),
        ));
        walk_with_clause(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_import_declaration(node, ctx);
}

pub(super) fn walk_import_declaration_specifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportDeclarationSpecifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_declaration_specifier(node, ctx);
    match node {
        ImportDeclarationSpecifier::ImportSpecifier(node) => {
            walk_import_specifier(traverser, node, ctx)
        }
        ImportDeclarationSpecifier::ImportDefaultSpecifier(node) => {
            walk_import_default_specifier(traverser, node, ctx)
        }
        ImportDeclarationSpecifier::ImportNamespaceSpecifier(node) => {
            walk_import_namespace_specifier(traverser, node, ctx)
        }
    }
    traverser.exit_import_declaration_specifier(node, ctx);
}

pub(super) fn walk_import_specifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportSpecifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_specifier(node, ctx);
    let field = &mut node.imported;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ImportSpecifierImported(ancestor::ImportSpecifierWithoutImported(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ImportSpecifier, span)) },
        PhantomData,
    )));
    walk_module_export_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.local;
    let other_field = &mut node.imported;
    ctx.push_stack(Ancestor::ImportSpecifierLocal(ancestor::ImportSpecifierWithoutLocal(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ImportSpecifier, imported))
        },
        PhantomData,
    )));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_import_specifier(node, ctx);
}

pub(super) fn walk_import_default_specifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportDefaultSpecifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_default_specifier(node, ctx);
    let field = &mut node.local;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ImportDefaultSpecifierLocal(
        ancestor::ImportDefaultSpecifierWithoutLocal(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ImportDefaultSpecifier, span))
        }),
    ));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_import_default_specifier(node, ctx);
}

pub(super) fn walk_import_namespace_specifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportNamespaceSpecifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_namespace_specifier(node, ctx);
    let field = &mut node.local;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ImportNamespaceSpecifierLocal(
        ancestor::ImportNamespaceSpecifierWithoutLocal(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(ImportNamespaceSpecifier, span))
        }),
    ));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_import_namespace_specifier(node, ctx);
}

pub(super) fn walk_with_clause<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut WithClause<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_with_clause(node, ctx);
    let field = &mut node.attributes_keyword;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::WithClauseAttributesKeyword(
        ancestor::WithClauseWithoutAttributesKeyword(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(WithClause, span)) },
            PhantomData,
        ),
    ));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.with_entries;
    let other_field = &mut node.attributes_keyword;
    ctx.push_stack(Ancestor::WithClauseWithEntries(ancestor::WithClauseWithoutWithEntries(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(WithClause, attributes_keyword))
        },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_import_attribute(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_with_clause(node, ctx);
}

pub(super) fn walk_import_attribute<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportAttribute<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_attribute(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ImportAttributeKey(ancestor::ImportAttributeWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ImportAttribute, span)) },
        PhantomData,
    )));
    walk_import_attribute_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    let other_field = &mut node.key;
    ctx.push_stack(Ancestor::ImportAttributeValue(ancestor::ImportAttributeWithoutValue(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ImportAttribute, key)) },
        PhantomData,
    )));
    walk_string_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_import_attribute(node, ctx);
}

pub(super) fn walk_import_attribute_key<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ImportAttributeKey<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_import_attribute_key(node, ctx);
    match node {
        ImportAttributeKey::Identifier(node) => walk_identifier_name(traverser, node, ctx),
        ImportAttributeKey::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
    }
    traverser.exit_import_attribute_key(node, ctx);
}

pub(super) fn walk_export_named_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ExportNamedDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_export_named_declaration(node, ctx);
    let field = &mut node.declaration;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ExportNamedDeclarationDeclaration(
            ancestor::ExportNamedDeclarationWithoutDeclaration(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ExportNamedDeclaration, span))
                },
                PhantomData,
            ),
        ));
        walk_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.specifiers;
    let other_field = &mut node.declaration;
    ctx.push_stack(Ancestor::ExportNamedDeclarationSpecifiers(
        ancestor::ExportNamedDeclarationWithoutSpecifiers(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ExportNamedDeclaration, declaration))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_export_specifier(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.source;
    if let Some(field) = field {
        let other_field = &mut node.specifiers;
        ctx.push_stack(Ancestor::ExportNamedDeclarationSource(
            ancestor::ExportNamedDeclarationWithoutSource(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ExportNamedDeclaration, specifiers))
                },
                PhantomData,
            ),
        ));
        walk_string_literal(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.with_clause;
    if let Some(field) = field {
        let other_field = &mut node.export_kind;
        ctx.push_stack(Ancestor::ExportNamedDeclarationWithClause(
            ancestor::ExportNamedDeclarationWithoutWithClause(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ExportNamedDeclaration, export_kind))
                },
                PhantomData,
            ),
        ));
        walk_with_clause(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_export_named_declaration(node, ctx);
}

pub(super) fn walk_export_default_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ExportDefaultDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_export_default_declaration(node, ctx);
    let field = &mut node.declaration;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ExportDefaultDeclarationDeclaration(
        ancestor::ExportDefaultDeclarationWithoutDeclaration(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ExportDefaultDeclaration, span))
            },
            PhantomData,
        ),
    ));
    walk_export_default_declaration_kind(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.exported;
    let other_field = &mut node.declaration;
    ctx.push_stack(Ancestor::ExportDefaultDeclarationExported(
        ancestor::ExportDefaultDeclarationWithoutExported(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ExportDefaultDeclaration, declaration))
            },
            PhantomData,
        ),
    ));
    walk_module_export_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_export_default_declaration(node, ctx);
}

pub(super) fn walk_export_all_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ExportAllDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_export_all_declaration(node, ctx);
    let field = &mut node.exported;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::ExportAllDeclarationExported(
            ancestor::ExportAllDeclarationWithoutExported(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ExportAllDeclaration, span))
                },
                PhantomData,
            ),
        ));
        walk_module_export_name(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.source;
    let other_field = &mut node.exported;
    ctx.push_stack(Ancestor::ExportAllDeclarationSource(
        ancestor::ExportAllDeclarationWithoutSource(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(ExportAllDeclaration, exported))
            },
            PhantomData,
        ),
    ));
    walk_string_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.with_clause;
    if let Some(field) = field {
        let other_field = &mut node.source;
        ctx.push_stack(Ancestor::ExportAllDeclarationWithClause(
            ancestor::ExportAllDeclarationWithoutWithClause(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(ExportAllDeclaration, source))
                },
                PhantomData,
            ),
        ));
        walk_with_clause(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_export_all_declaration(node, ctx);
}

pub(super) fn walk_export_specifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ExportSpecifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_export_specifier(node, ctx);
    let field = &mut node.local;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::ExportSpecifierLocal(ancestor::ExportSpecifierWithoutLocal(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ExportSpecifier, span)) },
        PhantomData,
    )));
    walk_module_export_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.exported;
    let other_field = &mut node.local;
    ctx.push_stack(Ancestor::ExportSpecifierExported(ancestor::ExportSpecifierWithoutExported(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(ExportSpecifier, local)) },
        PhantomData,
    )));
    walk_module_export_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_export_specifier(node, ctx);
}

pub(super) fn walk_export_default_declaration_kind<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ExportDefaultDeclarationKind<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_export_default_declaration_kind(node, ctx);
    match node {
        ExportDefaultDeclarationKind::FunctionDeclaration(node) => {
            walk_function(traverser, node, ctx)
        }
        ExportDefaultDeclarationKind::ClassDeclaration(node) => walk_class(traverser, node, ctx),
        ExportDefaultDeclarationKind::TSInterfaceDeclaration(node) => {
            walk_ts_interface_declaration(traverser, node, ctx)
        }
        ExportDefaultDeclarationKind::TSEnumDeclaration(node) => {
            walk_ts_enum_declaration(traverser, node, ctx)
        }
        match_expression!(ExportDefaultDeclarationKind) => {
            walk_expression(traverser, node.to_expression_mut(), ctx)
        }
    }
    traverser.exit_export_default_declaration_kind(node, ctx);
}

pub(super) fn walk_module_export_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut ModuleExportName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_module_export_name(node, ctx);
    match node {
        ModuleExportName::Identifier(node) => walk_identifier_name(traverser, node, ctx),
        ModuleExportName::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
    }
    traverser.exit_module_export_name(node, ctx);
}

pub(super) fn walk_jsx_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_element(node, ctx);
    let field = &mut node.opening_element;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXElementOpeningElement(ancestor::JSXElementWithoutOpeningElement(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(JSXElement, span)) },
        PhantomData,
    )));
    walk_jsx_opening_element(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.closing_element;
    if let Some(field) = field {
        let other_field = &mut node.opening_element;
        ctx.push_stack(Ancestor::JSXElementClosingElement(
            ancestor::JSXElementWithoutClosingElement(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(JSXElement, opening_element))
                },
                PhantomData,
            ),
        ));
        walk_jsx_closing_element(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.children;
    let other_field = &mut node.closing_element;
    ctx.push_stack(Ancestor::JSXElementChildren(ancestor::JSXElementWithoutChildren(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(JSXElement, closing_element))
        },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_jsx_child(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_element(node, ctx);
}

pub(super) fn walk_jsx_opening_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXOpeningElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_opening_element(node, ctx);
    let field = &mut node.name;
    let other_field = &mut node.self_closing;
    ctx.push_stack(Ancestor::JSXOpeningElementName(ancestor::JSXOpeningElementWithoutName(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(JSXOpeningElement, self_closing))
        },
        PhantomData,
    )));
    walk_jsx_element_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.attributes;
    let other_field = &mut node.name;
    ctx.push_stack(Ancestor::JSXOpeningElementAttributes(
        ancestor::JSXOpeningElementWithoutAttributes(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(JSXOpeningElement, name))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_jsx_attribute_item(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.attributes;
        ctx.push_stack(Ancestor::JSXOpeningElementTypeParameters(
            ancestor::JSXOpeningElementWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(JSXOpeningElement, attributes))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_jsx_opening_element(node, ctx);
}

pub(super) fn walk_jsx_closing_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXClosingElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_closing_element(node, ctx);
    let field = &mut node.name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXClosingElementName(ancestor::JSXClosingElementWithoutName(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(JSXClosingElement, span)) },
    )));
    walk_jsx_element_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_closing_element(node, ctx);
}

pub(super) fn walk_jsx_fragment<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXFragment<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_fragment(node, ctx);
    let field = &mut node.children;
    let other_field = &mut node.closing_fragment;
    ctx.push_stack(Ancestor::JSXFragmentChildren(ancestor::JSXFragmentWithoutChildren(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(JSXFragment, closing_fragment))
    })));
    for field in field.iter_mut() {
        walk_jsx_child(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_fragment(node, ctx);
}

pub(super) fn walk_jsx_element_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXElementName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_element_name(node, ctx);
    match node {
        JSXElementName::Identifier(node) => walk_jsx_identifier(traverser, node, ctx),
        JSXElementName::NamespacedName(node) => walk_jsx_namespaced_name(traverser, node, ctx),
        JSXElementName::MemberExpression(node) => walk_jsx_member_expression(traverser, node, ctx),
    }
    traverser.exit_jsx_element_name(node, ctx);
}

pub(super) fn walk_jsx_namespaced_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXNamespacedName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_namespaced_name(node, ctx);
    let field = &mut node.namespace;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXNamespacedNameNamespace(
        ancestor::JSXNamespacedNameWithoutNamespace(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(JSXNamespacedName, span))
            },
            PhantomData,
        ),
    ));
    walk_jsx_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.property;
    let other_field = &mut node.namespace;
    ctx.push_stack(Ancestor::JSXNamespacedNameProperty(
        ancestor::JSXNamespacedNameWithoutProperty(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(JSXNamespacedName, namespace))
            },
            PhantomData,
        ),
    ));
    walk_jsx_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_namespaced_name(node, ctx);
}

pub(super) fn walk_jsx_member_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXMemberExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_member_expression(node, ctx);
    let field = &mut node.object;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXMemberExpressionObject(
        ancestor::JSXMemberExpressionWithoutObject(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(JSXMemberExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_jsx_member_expression_object(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.property;
    let other_field = &mut node.object;
    ctx.push_stack(Ancestor::JSXMemberExpressionProperty(
        ancestor::JSXMemberExpressionWithoutProperty(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(JSXMemberExpression, object))
            },
            PhantomData,
        ),
    ));
    walk_jsx_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_member_expression(node, ctx);
}

pub(super) fn walk_jsx_member_expression_object<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXMemberExpressionObject<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_member_expression_object(node, ctx);
    match node {
        JSXMemberExpressionObject::Identifier(node) => walk_jsx_identifier(traverser, node, ctx),
        JSXMemberExpressionObject::MemberExpression(node) => {
            walk_jsx_member_expression(traverser, node, ctx)
        }
    }
    traverser.exit_jsx_member_expression_object(node, ctx);
}

pub(super) fn walk_jsx_expression_container<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXExpressionContainer<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_expression_container(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXExpressionContainerExpression(
        ancestor::JSXExpressionContainerWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(JSXExpressionContainer, span))
        }),
    ));
    walk_jsx_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_expression_container(node, ctx);
}

pub(super) fn walk_jsx_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_expression(node, ctx);
    match node {
        JSXExpression::EmptyExpression(node) => walk_jsx_empty_expression(traverser, node, ctx),
        match_expression!(JSXExpression) => {
            walk_expression(traverser, node.to_expression_mut(), ctx)
        }
    }
    traverser.exit_jsx_expression(node, ctx);
}

pub(super) fn walk_jsx_empty_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXEmptyExpression,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_empty_expression(node, ctx);
    traverser.exit_jsx_empty_expression(node, ctx);
}

pub(super) fn walk_jsx_attribute_item<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXAttributeItem<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_attribute_item(node, ctx);
    match node {
        JSXAttributeItem::Attribute(node) => walk_jsx_attribute(traverser, node, ctx),
        JSXAttributeItem::SpreadAttribute(node) => walk_jsx_spread_attribute(traverser, node, ctx),
    }
    traverser.exit_jsx_attribute_item(node, ctx);
}

pub(super) fn walk_jsx_attribute<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXAttribute<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_attribute(node, ctx);
    let field = &mut node.name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXAttributeName(ancestor::JSXAttributeWithoutName(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(JSXAttribute, span)) },
        PhantomData,
    )));
    walk_jsx_attribute_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    if let Some(field) = field {
        let other_field = &mut node.name;
        ctx.push_stack(Ancestor::JSXAttributeValue(ancestor::JSXAttributeWithoutValue(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(JSXAttribute, name)) },
            PhantomData,
        )));
        walk_jsx_attribute_value(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_jsx_attribute(node, ctx);
}

pub(super) fn walk_jsx_spread_attribute<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXSpreadAttribute<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_spread_attribute(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXSpreadAttributeArgument(
        ancestor::JSXSpreadAttributeWithoutArgument(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(JSXSpreadAttribute, span))
        }),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_spread_attribute(node, ctx);
}

pub(super) fn walk_jsx_attribute_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXAttributeName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_attribute_name(node, ctx);
    match node {
        JSXAttributeName::Identifier(node) => walk_jsx_identifier(traverser, node, ctx),
        JSXAttributeName::NamespacedName(node) => walk_jsx_namespaced_name(traverser, node, ctx),
    }
    traverser.exit_jsx_attribute_name(node, ctx);
}

pub(super) fn walk_jsx_attribute_value<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXAttributeValue<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_attribute_value(node, ctx);
    match node {
        JSXAttributeValue::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
        JSXAttributeValue::ExpressionContainer(node) => {
            walk_jsx_expression_container(traverser, node, ctx)
        }
        JSXAttributeValue::Element(node) => walk_jsx_element(traverser, node, ctx),
        JSXAttributeValue::Fragment(node) => walk_jsx_fragment(traverser, node, ctx),
    }
    traverser.exit_jsx_attribute_value(node, ctx);
}

pub(super) fn walk_jsx_identifier<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXIdentifier<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_identifier(node, ctx);
    traverser.exit_jsx_identifier(node, ctx);
}

pub(super) fn walk_jsx_child<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXChild<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_child(node, ctx);
    match node {
        JSXChild::Text(node) => walk_jsx_text(traverser, node, ctx),
        JSXChild::Element(node) => walk_jsx_element(traverser, node, ctx),
        JSXChild::Fragment(node) => walk_jsx_fragment(traverser, node, ctx),
        JSXChild::ExpressionContainer(node) => walk_jsx_expression_container(traverser, node, ctx),
        JSXChild::Spread(node) => walk_jsx_spread_child(traverser, node, ctx),
    }
    traverser.exit_jsx_child(node, ctx);
}

pub(super) fn walk_jsx_spread_child<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXSpreadChild<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_spread_child(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSXSpreadChildExpression(ancestor::JSXSpreadChildWithoutExpression(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(JSXSpreadChild, span)) },
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_jsx_spread_child(node, ctx);
}

pub(super) fn walk_jsx_text<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSXText<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_jsx_text(node, ctx);
    traverser.exit_jsx_text(node, ctx);
}

pub(super) fn walk_boolean_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BooleanLiteral,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_boolean_literal(node, ctx);
    traverser.exit_boolean_literal(node, ctx);
}

pub(super) fn walk_null_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut NullLiteral,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_null_literal(node, ctx);
    traverser.exit_null_literal(node, ctx);
}

pub(super) fn walk_numeric_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut NumericLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_numeric_literal(node, ctx);
    traverser.exit_numeric_literal(node, ctx);
}

pub(super) fn walk_big_int_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut BigIntLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_big_int_literal(node, ctx);
    traverser.exit_big_int_literal(node, ctx);
}

pub(super) fn walk_reg_exp_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut RegExpLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_reg_exp_literal(node, ctx);
    traverser.exit_reg_exp_literal(node, ctx);
}

pub(super) fn walk_string_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut StringLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_string_literal(node, ctx);
    traverser.exit_string_literal(node, ctx);
}

pub(super) fn walk_ts_this_parameter<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSThisParameter<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_this_parameter(node, ctx);
    let field = &mut node.this;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSThisParameterThis(ancestor::TSThisParameterWithoutThis(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSThisParameter, span)) },
        PhantomData,
    )));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    if let Some(field) = field {
        let other_field = &mut node.this;
        ctx.push_stack(Ancestor::TSThisParameterTypeAnnotation(
            ancestor::TSThisParameterWithoutTypeAnnotation(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSThisParameter, this))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_this_parameter(node, ctx);
}

pub(super) fn walk_ts_enum_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSEnumDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_enum_declaration(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSEnumDeclarationId(ancestor::TSEnumDeclarationWithoutId(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSEnumDeclaration, span)) },
        PhantomData,
    )));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.members;
    let other_field = &mut node.id;
    ctx.push_stack(Ancestor::TSEnumDeclarationMembers(ancestor::TSEnumDeclarationWithoutMembers(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSEnumDeclaration, id)) },
        PhantomData,
    )));
    for field in field.iter_mut() {
        walk_ts_enum_member(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_enum_declaration(node, ctx);
}

pub(super) fn walk_ts_enum_member<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSEnumMember<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_enum_member(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSEnumMemberId(ancestor::TSEnumMemberWithoutId(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSEnumMember, span)) },
        PhantomData,
    )));
    walk_ts_enum_member_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.initializer;
    if let Some(field) = field {
        let other_field = &mut node.id;
        ctx.push_stack(Ancestor::TSEnumMemberInitializer(
            ancestor::TSEnumMemberWithoutInitializer(
                unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSEnumMember, id)) },
                PhantomData,
            ),
        ));
        walk_expression(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_enum_member(node, ctx);
}

pub(super) fn walk_ts_enum_member_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSEnumMemberName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_enum_member_name(node, ctx);
    match node {
        TSEnumMemberName::StaticIdentifier(node) => walk_identifier_name(traverser, node, ctx),
        TSEnumMemberName::StaticStringLiteral(node) => walk_string_literal(traverser, node, ctx),
        TSEnumMemberName::StaticNumericLiteral(node) => walk_numeric_literal(traverser, node, ctx),
        match_expression!(TSEnumMemberName) => {
            walk_expression(traverser, node.to_expression_mut(), ctx)
        }
    }
    traverser.exit_ts_enum_member_name(node, ctx);
}

pub(super) fn walk_ts_type_annotation<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeAnnotation<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_annotation(node, ctx);
    let field = &mut node.type_annotation;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeAnnotationTypeAnnotation(
        ancestor::TSTypeAnnotationWithoutTypeAnnotation(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSTypeAnnotation, span))
        }),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_type_annotation(node, ctx);
}

pub(super) fn walk_ts_literal_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSLiteralType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_literal_type(node, ctx);
    let field = &mut node.literal;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSLiteralTypeLiteral(ancestor::TSLiteralTypeWithoutLiteral(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(TSLiteralType, span))
    })));
    walk_ts_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_literal_type(node, ctx);
}

pub(super) fn walk_ts_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_literal(node, ctx);
    match node {
        TSLiteral::BooleanLiteral(node) => walk_boolean_literal(traverser, node, ctx),
        TSLiteral::NullLiteral(node) => walk_null_literal(traverser, node, ctx),
        TSLiteral::NumericLiteral(node) => walk_numeric_literal(traverser, node, ctx),
        TSLiteral::BigintLiteral(node) => walk_big_int_literal(traverser, node, ctx),
        TSLiteral::RegExpLiteral(node) => walk_reg_exp_literal(traverser, node, ctx),
        TSLiteral::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
        TSLiteral::TemplateLiteral(node) => walk_template_literal(traverser, node, ctx),
        TSLiteral::UnaryExpression(node) => walk_unary_expression(traverser, node, ctx),
    }
    traverser.exit_ts_literal(node, ctx);
}

pub(super) fn walk_ts_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type(node, ctx);
    match node {
        TSType::TSAnyKeyword(node) => walk_ts_any_keyword(traverser, node, ctx),
        TSType::TSBigIntKeyword(node) => walk_ts_big_int_keyword(traverser, node, ctx),
        TSType::TSBooleanKeyword(node) => walk_ts_boolean_keyword(traverser, node, ctx),
        TSType::TSNeverKeyword(node) => walk_ts_never_keyword(traverser, node, ctx),
        TSType::TSNullKeyword(node) => walk_ts_null_keyword(traverser, node, ctx),
        TSType::TSNumberKeyword(node) => walk_ts_number_keyword(traverser, node, ctx),
        TSType::TSObjectKeyword(node) => walk_ts_object_keyword(traverser, node, ctx),
        TSType::TSStringKeyword(node) => walk_ts_string_keyword(traverser, node, ctx),
        TSType::TSSymbolKeyword(node) => walk_ts_symbol_keyword(traverser, node, ctx),
        TSType::TSThisType(node) => walk_ts_this_type(traverser, node, ctx),
        TSType::TSUndefinedKeyword(node) => walk_ts_undefined_keyword(traverser, node, ctx),
        TSType::TSUnknownKeyword(node) => walk_ts_unknown_keyword(traverser, node, ctx),
        TSType::TSVoidKeyword(node) => walk_ts_void_keyword(traverser, node, ctx),
        TSType::TSArrayType(node) => walk_ts_array_type(traverser, node, ctx),
        TSType::TSConditionalType(node) => walk_ts_conditional_type(traverser, node, ctx),
        TSType::TSConstructorType(node) => walk_ts_constructor_type(traverser, node, ctx),
        TSType::TSFunctionType(node) => walk_ts_function_type(traverser, node, ctx),
        TSType::TSImportType(node) => walk_ts_import_type(traverser, node, ctx),
        TSType::TSIndexedAccessType(node) => walk_ts_indexed_access_type(traverser, node, ctx),
        TSType::TSInferType(node) => walk_ts_infer_type(traverser, node, ctx),
        TSType::TSIntersectionType(node) => walk_ts_intersection_type(traverser, node, ctx),
        TSType::TSLiteralType(node) => walk_ts_literal_type(traverser, node, ctx),
        TSType::TSMappedType(node) => walk_ts_mapped_type(traverser, node, ctx),
        TSType::TSNamedTupleMember(node) => walk_ts_named_tuple_member(traverser, node, ctx),
        TSType::TSQualifiedName(node) => walk_ts_qualified_name(traverser, node, ctx),
        TSType::TSTemplateLiteralType(node) => walk_ts_template_literal_type(traverser, node, ctx),
        TSType::TSTupleType(node) => walk_ts_tuple_type(traverser, node, ctx),
        TSType::TSTypeLiteral(node) => walk_ts_type_literal(traverser, node, ctx),
        TSType::TSTypeOperatorType(node) => walk_ts_type_operator(traverser, node, ctx),
        TSType::TSTypePredicate(node) => walk_ts_type_predicate(traverser, node, ctx),
        TSType::TSTypeQuery(node) => walk_ts_type_query(traverser, node, ctx),
        TSType::TSTypeReference(node) => walk_ts_type_reference(traverser, node, ctx),
        TSType::TSUnionType(node) => walk_ts_union_type(traverser, node, ctx),
        TSType::JSDocNullableType(node) => walk_js_doc_nullable_type(traverser, node, ctx),
        TSType::JSDocUnknownType(node) => walk_js_doc_unknown_type(traverser, node, ctx),
    }
    traverser.exit_ts_type(node, ctx);
}

pub(super) fn walk_ts_conditional_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSConditionalType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_conditional_type(node, ctx);
    let field = &mut node.check_type;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSConditionalTypeCheckType(
        ancestor::TSConditionalTypeWithoutCheckType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSConditionalType, span))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.extends_type;
    let other_field = &mut node.check_type;
    ctx.push_stack(Ancestor::TSConditionalTypeExtendsType(
        ancestor::TSConditionalTypeWithoutExtendsType(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSConditionalType, check_type))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.true_type;
    let other_field = &mut node.extends_type;
    ctx.push_stack(Ancestor::TSConditionalTypeTrueType(
        ancestor::TSConditionalTypeWithoutTrueType(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSConditionalType, extends_type))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.false_type;
    let other_field = &mut node.true_type;
    ctx.push_stack(Ancestor::TSConditionalTypeFalseType(
        ancestor::TSConditionalTypeWithoutFalseType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSConditionalType, true_type))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_conditional_type(node, ctx);
}

pub(super) fn walk_ts_union_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSUnionType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_union_type(node, ctx);
    let field = &mut node.types;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSUnionTypeTypes(ancestor::TSUnionTypeWithoutTypes(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(TSUnionType, span))
    })));
    for field in field.iter_mut() {
        walk_ts_type(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_union_type(node, ctx);
}

pub(super) fn walk_ts_intersection_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSIntersectionType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_intersection_type(node, ctx);
    let field = &mut node.types;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSIntersectionTypeTypes(ancestor::TSIntersectionTypeWithoutTypes(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSIntersectionType, span)) },
    )));
    for field in field.iter_mut() {
        walk_ts_type(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_intersection_type(node, ctx);
}

pub(super) fn walk_ts_type_operator<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeOperator<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_operator(node, ctx);
    let field = &mut node.type_annotation;
    let other_field = &mut node.operator;
    ctx.push_stack(Ancestor::TSTypeOperatorTypeAnnotation(
        ancestor::TSTypeOperatorWithoutTypeAnnotation(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSTypeOperator, operator))
        }),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_type_operator(node, ctx);
}

pub(super) fn walk_ts_array_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSArrayType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_array_type(node, ctx);
    let field = &mut node.element_type;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSArrayTypeElementType(ancestor::TSArrayTypeWithoutElementType(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSArrayType, span)) },
    )));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_array_type(node, ctx);
}

pub(super) fn walk_ts_indexed_access_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSIndexedAccessType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_indexed_access_type(node, ctx);
    let field = &mut node.object_type;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSIndexedAccessTypeObjectType(
        ancestor::TSIndexedAccessTypeWithoutObjectType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSIndexedAccessType, span))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.index_type;
    let other_field = &mut node.object_type;
    ctx.push_stack(Ancestor::TSIndexedAccessTypeIndexType(
        ancestor::TSIndexedAccessTypeWithoutIndexType(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSIndexedAccessType, object_type))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_indexed_access_type(node, ctx);
}

pub(super) fn walk_ts_tuple_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTupleType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_tuple_type(node, ctx);
    let field = &mut node.element_types;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTupleTypeElementTypes(ancestor::TSTupleTypeWithoutElementTypes(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSTupleType, span)) },
    )));
    for field in field.iter_mut() {
        walk_ts_tuple_element(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_tuple_type(node, ctx);
}

pub(super) fn walk_ts_named_tuple_member<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSNamedTupleMember<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_named_tuple_member(node, ctx);
    let field = &mut node.element_type;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSNamedTupleMemberElementType(
        ancestor::TSNamedTupleMemberWithoutElementType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSNamedTupleMember, span))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.label;
    let other_field = &mut node.element_type;
    ctx.push_stack(Ancestor::TSNamedTupleMemberLabel(ancestor::TSNamedTupleMemberWithoutLabel(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSNamedTupleMember, element_type))
        },
        PhantomData,
    )));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_named_tuple_member(node, ctx);
}

pub(super) fn walk_ts_optional_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSOptionalType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_optional_type(node, ctx);
    let field = &mut node.type_annotation;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSOptionalTypeTypeAnnotation(
        ancestor::TSOptionalTypeWithoutTypeAnnotation(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSOptionalType, span))
        }),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_optional_type(node, ctx);
}

pub(super) fn walk_ts_rest_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSRestType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_rest_type(node, ctx);
    let field = &mut node.type_annotation;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSRestTypeTypeAnnotation(ancestor::TSRestTypeWithoutTypeAnnotation(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSRestType, span)) },
    )));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_rest_type(node, ctx);
}

pub(super) fn walk_ts_tuple_element<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTupleElement<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_tuple_element(node, ctx);
    match node {
        TSTupleElement::TSOptionalType(node) => walk_ts_optional_type(traverser, node, ctx),
        TSTupleElement::TSRestType(node) => walk_ts_rest_type(traverser, node, ctx),
        match_ts_type!(TSTupleElement) => walk_ts_type(traverser, node.to_ts_type_mut(), ctx),
    }
    traverser.exit_ts_tuple_element(node, ctx);
}

pub(super) fn walk_ts_any_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSAnyKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_any_keyword(node, ctx);
    traverser.exit_ts_any_keyword(node, ctx);
}

pub(super) fn walk_ts_string_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSStringKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_string_keyword(node, ctx);
    traverser.exit_ts_string_keyword(node, ctx);
}

pub(super) fn walk_ts_boolean_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSBooleanKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_boolean_keyword(node, ctx);
    traverser.exit_ts_boolean_keyword(node, ctx);
}

pub(super) fn walk_ts_number_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSNumberKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_number_keyword(node, ctx);
    traverser.exit_ts_number_keyword(node, ctx);
}

pub(super) fn walk_ts_never_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSNeverKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_never_keyword(node, ctx);
    traverser.exit_ts_never_keyword(node, ctx);
}

pub(super) fn walk_ts_unknown_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSUnknownKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_unknown_keyword(node, ctx);
    traverser.exit_ts_unknown_keyword(node, ctx);
}

pub(super) fn walk_ts_null_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSNullKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_null_keyword(node, ctx);
    traverser.exit_ts_null_keyword(node, ctx);
}

pub(super) fn walk_ts_undefined_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSUndefinedKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_undefined_keyword(node, ctx);
    traverser.exit_ts_undefined_keyword(node, ctx);
}

pub(super) fn walk_ts_void_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSVoidKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_void_keyword(node, ctx);
    traverser.exit_ts_void_keyword(node, ctx);
}

pub(super) fn walk_ts_symbol_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSSymbolKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_symbol_keyword(node, ctx);
    traverser.exit_ts_symbol_keyword(node, ctx);
}

pub(super) fn walk_ts_this_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSThisType,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_this_type(node, ctx);
    traverser.exit_ts_this_type(node, ctx);
}

pub(super) fn walk_ts_object_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSObjectKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_object_keyword(node, ctx);
    traverser.exit_ts_object_keyword(node, ctx);
}

pub(super) fn walk_ts_big_int_keyword<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSBigIntKeyword,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_big_int_keyword(node, ctx);
    traverser.exit_ts_big_int_keyword(node, ctx);
}

pub(super) fn walk_ts_type_reference<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeReference<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_reference(node, ctx);
    let field = &mut node.type_name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeReferenceTypeName(ancestor::TSTypeReferenceWithoutTypeName(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSTypeReference, span)) },
        PhantomData,
    )));
    walk_ts_type_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.type_name;
        ctx.push_stack(Ancestor::TSTypeReferenceTypeParameters(
            ancestor::TSTypeReferenceWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSTypeReference, type_name))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_type_reference(node, ctx);
}

pub(super) fn walk_ts_type_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_name(node, ctx);
    match node {
        TSTypeName::IdentifierReference(node) => walk_identifier_reference(traverser, node, ctx),
        TSTypeName::QualifiedName(node) => walk_ts_qualified_name(traverser, node, ctx),
    }
    traverser.exit_ts_type_name(node, ctx);
}

pub(super) fn walk_ts_qualified_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSQualifiedName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_qualified_name(node, ctx);
    let field = &mut node.left;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSQualifiedNameLeft(ancestor::TSQualifiedNameWithoutLeft(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSQualifiedName, span)) },
        PhantomData,
    )));
    walk_ts_type_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.right;
    let other_field = &mut node.left;
    ctx.push_stack(Ancestor::TSQualifiedNameRight(ancestor::TSQualifiedNameWithoutRight(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSQualifiedName, left)) },
        PhantomData,
    )));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_qualified_name(node, ctx);
}

pub(super) fn walk_ts_type_parameter_instantiation<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeParameterInstantiation<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_parameter_instantiation(node, ctx);
    let field = &mut node.params;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeParameterInstantiationParams(
        ancestor::TSTypeParameterInstantiationWithoutParams(unsafe {
            (other_field as *const _ as *const u8)
                .sub(offset_of!(TSTypeParameterInstantiation, span))
        }),
    ));
    for field in field.iter_mut() {
        walk_ts_type(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_type_parameter_instantiation(node, ctx);
}

pub(super) fn walk_ts_type_parameter<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeParameter<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_parameter(node, ctx);
    let field = &mut node.name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeParameterName(ancestor::TSTypeParameterWithoutName(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSTypeParameter, span)) },
        PhantomData,
    )));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.constraint;
    if let Some(field) = field {
        let other_field = &mut node.name;
        ctx.push_stack(Ancestor::TSTypeParameterConstraint(
            ancestor::TSTypeParameterWithoutConstraint(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSTypeParameter, name))
                },
                PhantomData,
            ),
        ));
        walk_ts_type(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.default;
    if let Some(field) = field {
        let other_field = &mut node.constraint;
        ctx.push_stack(Ancestor::TSTypeParameterDefault(ancestor::TSTypeParameterWithoutDefault(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSTypeParameter, constraint))
            },
            PhantomData,
        )));
        walk_ts_type(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_type_parameter(node, ctx);
}

pub(super) fn walk_ts_type_parameter_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeParameterDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_parameter_declaration(node, ctx);
    let field = &mut node.params;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeParameterDeclarationParams(
        ancestor::TSTypeParameterDeclarationWithoutParams(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSTypeParameterDeclaration, span))
        }),
    ));
    for field in field.iter_mut() {
        walk_ts_type_parameter(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_type_parameter_declaration(node, ctx);
}

pub(super) fn walk_ts_type_alias_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeAliasDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_alias_declaration(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeAliasDeclarationId(ancestor::TSTypeAliasDeclarationWithoutId(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSTypeAliasDeclaration, span))
        },
        PhantomData,
    )));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    let other_field = &mut node.id;
    ctx.push_stack(Ancestor::TSTypeAliasDeclarationTypeAnnotation(
        ancestor::TSTypeAliasDeclarationWithoutTypeAnnotation(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSTypeAliasDeclaration, id))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.type_annotation;
        ctx.push_stack(Ancestor::TSTypeAliasDeclarationTypeParameters(
            ancestor::TSTypeAliasDeclarationWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSTypeAliasDeclaration, type_annotation))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_type_alias_declaration(node, ctx);
}

pub(super) fn walk_ts_class_implements<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSClassImplements<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_class_implements(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSClassImplementsExpression(
        ancestor::TSClassImplementsWithoutExpression(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSClassImplements, span))
            },
            PhantomData,
        ),
    ));
    walk_ts_type_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.expression;
        ctx.push_stack(Ancestor::TSClassImplementsTypeParameters(
            ancestor::TSClassImplementsWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSClassImplements, expression))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_class_implements(node, ctx);
}

pub(super) fn walk_ts_interface_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSInterfaceDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_interface_declaration(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSInterfaceDeclarationId(ancestor::TSInterfaceDeclarationWithoutId(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSInterfaceDeclaration, span))
        },
        PhantomData,
    )));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    let other_field = &mut node.id;
    ctx.push_stack(Ancestor::TSInterfaceDeclarationBody(
        ancestor::TSInterfaceDeclarationWithoutBody(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSInterfaceDeclaration, id))
            },
            PhantomData,
        ),
    ));
    walk_ts_interface_body(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.body;
        ctx.push_stack(Ancestor::TSInterfaceDeclarationTypeParameters(
            ancestor::TSInterfaceDeclarationWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSInterfaceDeclaration, body))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.extends;
    if let Some(field) = field {
        let other_field = &mut node.type_parameters;
        ctx.push_stack(Ancestor::TSInterfaceDeclarationExtends(
            ancestor::TSInterfaceDeclarationWithoutExtends(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSInterfaceDeclaration, type_parameters))
                },
                PhantomData,
            ),
        ));
        for field in field.iter_mut() {
            walk_ts_interface_heritage(traverser, field, ctx);
        }
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_interface_declaration(node, ctx);
}

pub(super) fn walk_ts_interface_body<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSInterfaceBody<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_interface_body(node, ctx);
    let field = &mut node.body;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSInterfaceBodyBody(ancestor::TSInterfaceBodyWithoutBody(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(TSInterfaceBody, span))
    })));
    for field in field.iter_mut() {
        walk_ts_signature(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_interface_body(node, ctx);
}

pub(super) fn walk_ts_property_signature<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSPropertySignature<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_property_signature(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.readonly;
    ctx.push_stack(Ancestor::TSPropertySignatureKey(ancestor::TSPropertySignatureWithoutKey(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSPropertySignature, readonly))
        },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    if let Some(field) = field {
        let other_field = &mut node.key;
        ctx.push_stack(Ancestor::TSPropertySignatureTypeAnnotation(
            ancestor::TSPropertySignatureWithoutTypeAnnotation(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSPropertySignature, key))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_property_signature(node, ctx);
}

pub(super) fn walk_ts_signature<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSSignature<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_signature(node, ctx);
    match node {
        TSSignature::TSIndexSignature(node) => walk_ts_index_signature(traverser, node, ctx),
        TSSignature::TSPropertySignature(node) => walk_ts_property_signature(traverser, node, ctx),
        TSSignature::TSCallSignatureDeclaration(node) => {
            walk_ts_call_signature_declaration(traverser, node, ctx)
        }
        TSSignature::TSConstructSignatureDeclaration(node) => {
            walk_ts_construct_signature_declaration(traverser, node, ctx)
        }
        TSSignature::TSMethodSignature(node) => walk_ts_method_signature(traverser, node, ctx),
    }
    traverser.exit_ts_signature(node, ctx);
}

pub(super) fn walk_ts_index_signature<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSIndexSignature<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_index_signature(node, ctx);
    let field = &mut node.parameters;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSIndexSignatureParameters(
        ancestor::TSIndexSignatureWithoutParameters(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSIndexSignature, span))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_ts_index_signature_name(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    let other_field = &mut node.parameters;
    ctx.push_stack(Ancestor::TSIndexSignatureTypeAnnotation(
        ancestor::TSIndexSignatureWithoutTypeAnnotation(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSIndexSignature, parameters))
            },
            PhantomData,
        ),
    ));
    walk_ts_type_annotation(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_index_signature(node, ctx);
}

pub(super) fn walk_ts_call_signature_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSCallSignatureDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_call_signature_declaration(node, ctx);
    let field = &mut node.this_param;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::TSCallSignatureDeclarationThisParam(
            ancestor::TSCallSignatureDeclarationWithoutThisParam(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSCallSignatureDeclaration, span))
                },
                PhantomData,
            ),
        ));
        walk_ts_this_parameter(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.params;
    let other_field = &mut node.this_param;
    ctx.push_stack(Ancestor::TSCallSignatureDeclarationParams(
        ancestor::TSCallSignatureDeclarationWithoutParams(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSCallSignatureDeclaration, this_param))
            },
            PhantomData,
        ),
    ));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.return_type;
    if let Some(field) = field {
        let other_field = &mut node.params;
        ctx.push_stack(Ancestor::TSCallSignatureDeclarationReturnType(
            ancestor::TSCallSignatureDeclarationWithoutReturnType(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSCallSignatureDeclaration, params))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.return_type;
        ctx.push_stack(Ancestor::TSCallSignatureDeclarationTypeParameters(
            ancestor::TSCallSignatureDeclarationWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSCallSignatureDeclaration, return_type))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_call_signature_declaration(node, ctx);
}

pub(super) fn walk_ts_method_signature<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSMethodSignature<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_method_signature(node, ctx);
    let field = &mut node.key;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSMethodSignatureKey(ancestor::TSMethodSignatureWithoutKey(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSMethodSignature, span)) },
        PhantomData,
    )));
    walk_property_key(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.this_param;
    if let Some(field) = field {
        let other_field = &mut node.kind;
        ctx.push_stack(Ancestor::TSMethodSignatureThisParam(
            ancestor::TSMethodSignatureWithoutThisParam(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSMethodSignature, kind))
                },
                PhantomData,
            ),
        ));
        walk_ts_this_parameter(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.params;
    let other_field = &mut node.this_param;
    ctx.push_stack(Ancestor::TSMethodSignatureParams(ancestor::TSMethodSignatureWithoutParams(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSMethodSignature, this_param))
        },
        PhantomData,
    )));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.return_type;
    if let Some(field) = field {
        let other_field = &mut node.params;
        ctx.push_stack(Ancestor::TSMethodSignatureReturnType(
            ancestor::TSMethodSignatureWithoutReturnType(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSMethodSignature, params))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.return_type;
        ctx.push_stack(Ancestor::TSMethodSignatureTypeParameters(
            ancestor::TSMethodSignatureWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSMethodSignature, return_type))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_method_signature(node, ctx);
}

pub(super) fn walk_ts_construct_signature_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSConstructSignatureDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_construct_signature_declaration(node, ctx);
    let field = &mut node.params;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSConstructSignatureDeclarationParams(
        ancestor::TSConstructSignatureDeclarationWithoutParams(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSConstructSignatureDeclaration, span))
            },
            PhantomData,
        ),
    ));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.return_type;
    if let Some(field) = field {
        let other_field = &mut node.params;
        ctx.push_stack(Ancestor::TSConstructSignatureDeclarationReturnType(
            ancestor::TSConstructSignatureDeclarationWithoutReturnType(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSConstructSignatureDeclaration, params))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.return_type;
        ctx.push_stack(Ancestor::TSConstructSignatureDeclarationTypeParameters(
            ancestor::TSConstructSignatureDeclarationWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSConstructSignatureDeclaration, return_type))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_construct_signature_declaration(node, ctx);
}

pub(super) fn walk_ts_index_signature_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSIndexSignatureName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_index_signature_name(node, ctx);
    let field = &mut node.type_annotation;
    let other_field = &mut node.name;
    ctx.push_stack(Ancestor::TSIndexSignatureNameTypeAnnotation(
        ancestor::TSIndexSignatureNameWithoutTypeAnnotation(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSIndexSignatureName, name))
            },
            PhantomData,
        ),
    ));
    walk_ts_type_annotation(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_index_signature_name(node, ctx);
}

pub(super) fn walk_ts_interface_heritage<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSInterfaceHeritage<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_interface_heritage(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSInterfaceHeritageExpression(
        ancestor::TSInterfaceHeritageWithoutExpression(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSInterfaceHeritage, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.expression;
        ctx.push_stack(Ancestor::TSInterfaceHeritageTypeParameters(
            ancestor::TSInterfaceHeritageWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSInterfaceHeritage, expression))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_interface_heritage(node, ctx);
}

pub(super) fn walk_ts_type_predicate<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypePredicate<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_predicate(node, ctx);
    let field = &mut node.parameter_name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypePredicateParameterName(
        ancestor::TSTypePredicateWithoutParameterName(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSTypePredicate, span))
            },
            PhantomData,
        ),
    ));
    walk_ts_type_predicate_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    if let Some(field) = field {
        let other_field = &mut node.asserts;
        ctx.push_stack(Ancestor::TSTypePredicateTypeAnnotation(
            ancestor::TSTypePredicateWithoutTypeAnnotation(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSTypePredicate, asserts))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_annotation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_type_predicate(node, ctx);
}

pub(super) fn walk_ts_type_predicate_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypePredicateName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_predicate_name(node, ctx);
    match node {
        TSTypePredicateName::Identifier(node) => walk_identifier_name(traverser, node, ctx),
        TSTypePredicateName::This(node) => walk_ts_this_type(traverser, node, ctx),
    }
    traverser.exit_ts_type_predicate_name(node, ctx);
}

pub(super) fn walk_ts_module_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSModuleDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_module_declaration(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSModuleDeclarationId(ancestor::TSModuleDeclarationWithoutId(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSModuleDeclaration, span))
        },
        PhantomData,
    )));
    walk_ts_module_declaration_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.body;
    if let Some(field) = field {
        let other_field = &mut node.id;
        ctx.push_stack(Ancestor::TSModuleDeclarationBody(
            ancestor::TSModuleDeclarationWithoutBody(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSModuleDeclaration, id))
                },
                PhantomData,
            ),
        ));
        walk_ts_module_declaration_body(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_module_declaration(node, ctx);
}

pub(super) fn walk_ts_module_declaration_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSModuleDeclarationName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_module_declaration_name(node, ctx);
    match node {
        TSModuleDeclarationName::Identifier(node) => walk_identifier_name(traverser, node, ctx),
        TSModuleDeclarationName::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
    }
    traverser.exit_ts_module_declaration_name(node, ctx);
}

pub(super) fn walk_ts_module_declaration_body<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSModuleDeclarationBody<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_module_declaration_body(node, ctx);
    match node {
        TSModuleDeclarationBody::TSModuleDeclaration(node) => {
            walk_ts_module_declaration(traverser, node, ctx)
        }
        TSModuleDeclarationBody::TSModuleBlock(node) => walk_ts_module_block(traverser, node, ctx),
    }
    traverser.exit_ts_module_declaration_body(node, ctx);
}

pub(super) fn walk_ts_module_block<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSModuleBlock<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_module_block(node, ctx);
    let field = &mut node.body;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSModuleBlockBody(ancestor::TSModuleBlockWithoutBody(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(TSModuleBlock, span))
    })));
    walk_statements(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_module_block(node, ctx);
}

pub(super) fn walk_ts_type_literal<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeLiteral<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_literal(node, ctx);
    let field = &mut node.members;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeLiteralMembers(ancestor::TSTypeLiteralWithoutMembers(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(TSTypeLiteral, span))
    })));
    for field in field.iter_mut() {
        walk_ts_signature(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_type_literal(node, ctx);
}

pub(super) fn walk_ts_infer_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSInferType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_infer_type(node, ctx);
    let field = &mut node.type_parameter;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSInferTypeTypeParameter(ancestor::TSInferTypeWithoutTypeParameter(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSInferType, span)) },
    )));
    walk_ts_type_parameter(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_infer_type(node, ctx);
}

pub(super) fn walk_ts_type_query<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeQuery<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_query(node, ctx);
    let field = &mut node.expr_name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeQueryExprName(ancestor::TSTypeQueryWithoutExprName(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSTypeQuery, span)) },
        PhantomData,
    )));
    walk_ts_type_query_expr_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.expr_name;
        ctx.push_stack(Ancestor::TSTypeQueryTypeParameters(
            ancestor::TSTypeQueryWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSTypeQuery, expr_name))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_type_query(node, ctx);
}

pub(super) fn walk_ts_type_query_expr_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeQueryExprName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_query_expr_name(node, ctx);
    match node {
        TSTypeQueryExprName::TSImportType(node) => walk_ts_import_type(traverser, node, ctx),
        match_ts_type_name!(TSTypeQueryExprName) => {
            walk_ts_type_name(traverser, node.to_ts_type_name_mut(), ctx)
        }
    }
    traverser.exit_ts_type_query_expr_name(node, ctx);
}

pub(super) fn walk_ts_import_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSImportType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_import_type(node, ctx);
    let field = &mut node.argument;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSImportTypeArgument(ancestor::TSImportTypeWithoutArgument(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSImportType, span)) },
        PhantomData,
    )));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.qualifier;
    if let Some(field) = field {
        let other_field = &mut node.argument;
        ctx.push_stack(Ancestor::TSImportTypeQualifier(ancestor::TSImportTypeWithoutQualifier(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSImportType, argument))
            },
            PhantomData,
        )));
        walk_ts_type_name(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.attributes;
    if let Some(field) = field {
        let other_field = &mut node.qualifier;
        ctx.push_stack(Ancestor::TSImportTypeAttributes(ancestor::TSImportTypeWithoutAttributes(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSImportType, qualifier))
            },
            PhantomData,
        )));
        walk_ts_import_attributes(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.attributes;
        ctx.push_stack(Ancestor::TSImportTypeTypeParameters(
            ancestor::TSImportTypeWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSImportType, attributes))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_instantiation(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_import_type(node, ctx);
}

pub(super) fn walk_ts_import_attributes<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSImportAttributes<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_import_attributes(node, ctx);
    let field = &mut node.elements;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSImportAttributesElements(
        ancestor::TSImportAttributesWithoutElements(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSImportAttributes, span))
        }),
    ));
    for field in field.iter_mut() {
        walk_ts_import_attribute(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_import_attributes(node, ctx);
}

pub(super) fn walk_ts_import_attribute<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSImportAttribute<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_import_attribute(node, ctx);
    let field = &mut node.name;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSImportAttributeName(ancestor::TSImportAttributeWithoutName(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSImportAttribute, span)) },
        PhantomData,
    )));
    walk_ts_import_attribute_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.value;
    let other_field = &mut node.name;
    ctx.push_stack(Ancestor::TSImportAttributeValue(ancestor::TSImportAttributeWithoutValue(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSImportAttribute, name)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_import_attribute(node, ctx);
}

pub(super) fn walk_ts_import_attribute_name<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSImportAttributeName<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_import_attribute_name(node, ctx);
    match node {
        TSImportAttributeName::Identifier(node) => walk_identifier_name(traverser, node, ctx),
        TSImportAttributeName::StringLiteral(node) => walk_string_literal(traverser, node, ctx),
    }
    traverser.exit_ts_import_attribute_name(node, ctx);
}

pub(super) fn walk_ts_function_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSFunctionType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_function_type(node, ctx);
    let field = &mut node.this_param;
    if let Some(field) = field {
        let other_field = &mut node.span;
        ctx.push_stack(Ancestor::TSFunctionTypeThisParam(
            ancestor::TSFunctionTypeWithoutThisParam(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSFunctionType, span))
                },
                PhantomData,
            ),
        ));
        walk_ts_this_parameter(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.params;
    let other_field = &mut node.this_param;
    ctx.push_stack(Ancestor::TSFunctionTypeParams(ancestor::TSFunctionTypeWithoutParams(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSFunctionType, this_param))
        },
        PhantomData,
    )));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.return_type;
    let other_field = &mut node.params;
    ctx.push_stack(Ancestor::TSFunctionTypeReturnType(ancestor::TSFunctionTypeWithoutReturnType(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSFunctionType, params)) },
        PhantomData,
    )));
    walk_ts_type_annotation(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.return_type;
        ctx.push_stack(Ancestor::TSFunctionTypeTypeParameters(
            ancestor::TSFunctionTypeWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSFunctionType, return_type))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_function_type(node, ctx);
}

pub(super) fn walk_ts_constructor_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSConstructorType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_constructor_type(node, ctx);
    let field = &mut node.params;
    let other_field = &mut node.r#abstract;
    ctx.push_stack(Ancestor::TSConstructorTypeParams(ancestor::TSConstructorTypeWithoutParams(
        unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSConstructorType, r#abstract))
        },
        PhantomData,
    )));
    walk_formal_parameters(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.return_type;
    let other_field = &mut node.params;
    ctx.push_stack(Ancestor::TSConstructorTypeReturnType(
        ancestor::TSConstructorTypeWithoutReturnType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSConstructorType, params))
            },
            PhantomData,
        ),
    ));
    walk_ts_type_annotation(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    if let Some(field) = field {
        let other_field = &mut node.return_type;
        ctx.push_stack(Ancestor::TSConstructorTypeTypeParameters(
            ancestor::TSConstructorTypeWithoutTypeParameters(
                unsafe {
                    (other_field as *const _ as *const u8)
                        .sub(offset_of!(TSConstructorType, return_type))
                },
                PhantomData,
            ),
        ));
        walk_ts_type_parameter_declaration(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_constructor_type(node, ctx);
}

pub(super) fn walk_ts_mapped_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSMappedType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_mapped_type(node, ctx);
    let field = &mut node.type_parameter;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSMappedTypeTypeParameter(
        ancestor::TSMappedTypeWithoutTypeParameter(
            unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSMappedType, span)) },
            PhantomData,
        ),
    ));
    walk_ts_type_parameter(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.name_type;
    if let Some(field) = field {
        let other_field = &mut node.type_parameter;
        ctx.push_stack(Ancestor::TSMappedTypeNameType(ancestor::TSMappedTypeWithoutNameType(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSMappedType, type_parameter))
            },
            PhantomData,
        )));
        walk_ts_type(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    let field = &mut node.type_annotation;
    if let Some(field) = field {
        let other_field = &mut node.name_type;
        ctx.push_stack(Ancestor::TSMappedTypeTypeAnnotation(
            ancestor::TSMappedTypeWithoutTypeAnnotation(
                unsafe {
                    (other_field as *const _ as *const u8).sub(offset_of!(TSMappedType, name_type))
                },
                PhantomData,
            ),
        ));
        walk_ts_type(traverser, field, ctx);
        unsafe { ctx.pop_stack() };
    }
    traverser.exit_ts_mapped_type(node, ctx);
}

pub(super) fn walk_ts_template_literal_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTemplateLiteralType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_template_literal_type(node, ctx);
    let field = &mut node.quasis;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTemplateLiteralTypeQuasis(
        ancestor::TSTemplateLiteralTypeWithoutQuasis(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSTemplateLiteralType, span))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_template_element(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    let field = &mut node.types;
    let other_field = &mut node.quasis;
    ctx.push_stack(Ancestor::TSTemplateLiteralTypeTypes(
        ancestor::TSTemplateLiteralTypeWithoutTypes(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSTemplateLiteralType, quasis))
            },
            PhantomData,
        ),
    ));
    for field in field.iter_mut() {
        walk_ts_type(traverser, field, ctx);
    }
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_template_literal_type(node, ctx);
}

pub(super) fn walk_ts_as_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSAsExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_as_expression(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSAsExpressionExpression(ancestor::TSAsExpressionWithoutExpression(
        unsafe { (other_field as *const _ as *const u8).sub(offset_of!(TSAsExpression, span)) },
        PhantomData,
    )));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    let other_field = &mut node.expression;
    ctx.push_stack(Ancestor::TSAsExpressionTypeAnnotation(
        ancestor::TSAsExpressionWithoutTypeAnnotation(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSAsExpression, expression))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_as_expression(node, ctx);
}

pub(super) fn walk_ts_satisfies_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSSatisfiesExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_satisfies_expression(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSSatisfiesExpressionExpression(
        ancestor::TSSatisfiesExpressionWithoutExpression(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSSatisfiesExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    let other_field = &mut node.expression;
    ctx.push_stack(Ancestor::TSSatisfiesExpressionTypeAnnotation(
        ancestor::TSSatisfiesExpressionWithoutTypeAnnotation(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSSatisfiesExpression, expression))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_satisfies_expression(node, ctx);
}

pub(super) fn walk_ts_type_assertion<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSTypeAssertion<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_type_assertion(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSTypeAssertionExpression(
        ancestor::TSTypeAssertionWithoutExpression(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSTypeAssertion, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_annotation;
    let other_field = &mut node.expression;
    ctx.push_stack(Ancestor::TSTypeAssertionTypeAnnotation(
        ancestor::TSTypeAssertionWithoutTypeAnnotation(
            unsafe {
                (other_field as *const _ as *const u8).sub(offset_of!(TSTypeAssertion, expression))
            },
            PhantomData,
        ),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_type_assertion(node, ctx);
}

pub(super) fn walk_ts_import_equals_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSImportEqualsDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_import_equals_declaration(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSImportEqualsDeclarationId(
        ancestor::TSImportEqualsDeclarationWithoutId(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSImportEqualsDeclaration, span))
            },
            PhantomData,
        ),
    ));
    walk_binding_identifier(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.module_reference;
    let other_field = &mut node.id;
    ctx.push_stack(Ancestor::TSImportEqualsDeclarationModuleReference(
        ancestor::TSImportEqualsDeclarationWithoutModuleReference(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSImportEqualsDeclaration, id))
            },
            PhantomData,
        ),
    ));
    walk_ts_module_reference(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_import_equals_declaration(node, ctx);
}

pub(super) fn walk_ts_module_reference<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSModuleReference<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_module_reference(node, ctx);
    match node {
        TSModuleReference::ExternalModuleReference(node) => {
            walk_ts_external_module_reference(traverser, node, ctx)
        }
        match_ts_type_name!(TSModuleReference) => {
            walk_ts_type_name(traverser, node.to_ts_type_name_mut(), ctx)
        }
    }
    traverser.exit_ts_module_reference(node, ctx);
}

pub(super) fn walk_ts_external_module_reference<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSExternalModuleReference<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_external_module_reference(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSExternalModuleReferenceExpression(
        ancestor::TSExternalModuleReferenceWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSExternalModuleReference, span))
        }),
    ));
    walk_string_literal(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_external_module_reference(node, ctx);
}

pub(super) fn walk_ts_non_null_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSNonNullExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_non_null_expression(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSNonNullExpressionExpression(
        ancestor::TSNonNullExpressionWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSNonNullExpression, span))
        }),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_non_null_expression(node, ctx);
}

pub(super) fn walk_decorator<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut Decorator<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_decorator(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::DecoratorExpression(ancestor::DecoratorWithoutExpression(unsafe {
        (other_field as *const _ as *const u8).sub(offset_of!(Decorator, span))
    })));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_decorator(node, ctx);
}

pub(super) fn walk_ts_export_assignment<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSExportAssignment<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_export_assignment(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSExportAssignmentExpression(
        ancestor::TSExportAssignmentWithoutExpression(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(TSExportAssignment, span))
        }),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_export_assignment(node, ctx);
}

pub(super) fn walk_ts_namespace_export_declaration<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSNamespaceExportDeclaration<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_namespace_export_declaration(node, ctx);
    let field = &mut node.id;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSNamespaceExportDeclarationId(
        ancestor::TSNamespaceExportDeclarationWithoutId(unsafe {
            (other_field as *const _ as *const u8)
                .sub(offset_of!(TSNamespaceExportDeclaration, span))
        }),
    ));
    walk_identifier_name(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_namespace_export_declaration(node, ctx);
}

pub(super) fn walk_ts_instantiation_expression<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut TSInstantiationExpression<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_ts_instantiation_expression(node, ctx);
    let field = &mut node.expression;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::TSInstantiationExpressionExpression(
        ancestor::TSInstantiationExpressionWithoutExpression(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSInstantiationExpression, span))
            },
            PhantomData,
        ),
    ));
    walk_expression(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    let field = &mut node.type_parameters;
    let other_field = &mut node.expression;
    ctx.push_stack(Ancestor::TSInstantiationExpressionTypeParameters(
        ancestor::TSInstantiationExpressionWithoutTypeParameters(
            unsafe {
                (other_field as *const _ as *const u8)
                    .sub(offset_of!(TSInstantiationExpression, expression))
            },
            PhantomData,
        ),
    ));
    walk_ts_type_parameter_instantiation(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_ts_instantiation_expression(node, ctx);
}

pub(super) fn walk_js_doc_nullable_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSDocNullableType<'a>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_js_doc_nullable_type(node, ctx);
    let field = &mut node.type_annotation;
    let other_field = &mut node.span;
    ctx.push_stack(Ancestor::JSDocNullableTypeTypeAnnotation(
        ancestor::JSDocNullableTypeWithoutTypeAnnotation(unsafe {
            (other_field as *const _ as *const u8).sub(offset_of!(JSDocNullableType, span))
        }),
    ));
    walk_ts_type(traverser, field, ctx);
    unsafe { ctx.pop_stack() };
    traverser.exit_js_doc_nullable_type(node, ctx);
}

pub(super) fn walk_js_doc_unknown_type<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    node: &mut JSDocUnknownType,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_js_doc_unknown_type(node, ctx);
    traverser.exit_js_doc_unknown_type(node, ctx);
}

pub(super) fn walk_statements<'a, Tr: Traverse<'a>>(
    traverser: &mut Tr,
    stmts: &mut Vec<'a, Statement<'a>>,
    ctx: &mut TraverseCtx<'a>,
) {
    traverser.enter_statements(stmts, ctx);
    for stmt in stmts.iter_mut() {
        walk_statement(traverser, stmt, ctx);
    }
    traverser.exit_statements(stmts, ctx);
}

/*
 * Codegen for `traverse`.
 *
 * Parses Rust AST type definitions from files in `crates/oxc_ast/src/ast`, and generates:
 * - `src/traverse.rs`
 * - `src/ancestor.rs`
 * - `src/walk.rs`
 *
 * This is a quick-and-dirty version written in JS for speed of implementation.
 * We should do this properly with a Rust build script using `syn` etc.
 */

import {readFile, writeFile} from 'fs/promises';
import {exec} from 'child_process';
import {join as pathJoin} from 'path';
import {fileURLToPath} from 'url';
import {promisify} from 'util';
import assert from 'assert';

const execAsync = promisify(exec);

const PREAMBLE = '// Generated by `scripts/build.mjs`.';

const types = await getTypesFromCode();

const outputDirPath = pathJoin(fileURLToPath(import.meta.url), '../../src');
await writeToFile('traverse.rs', generateTraverseTraitCode(types));
await writeToFile('ancestor.rs', generateAncestorsCode(types));
await writeToFile('walk.rs', generateWalkFunctionsCode(types));

// TODO: Remove `todo!` insertions into code and throw error here instead

function generateTraverseTraitCode(types) {
    let traverseMethods = '';
    for (const type of Object.values(types)) {
        const snakeName = camelToSnake(type.name);
        const ty = toTypeName(type);
        traverseMethods += `
            #[inline]
            fn enter_${snakeName}(&mut self, node: &mut ${ty}, ctx: &TraverseCtx<'a>) {}
            #[inline]
            fn exit_${snakeName}(&mut self, node: &mut ${ty}, ctx: &TraverseCtx<'a>) {}
        `;
    }

    return `
        ${PREAMBLE}

        use oxc_allocator::Vec;
        #[allow(clippy::wildcard_imports)]
        use oxc_ast::ast::*;

        use crate::TraverseCtx;

        #[allow(unused_variables)]
        pub trait Traverse<'a> {
            ${traverseMethods}

            #[inline]
            fn enter_statements(&mut self, node: &mut Vec<'a, Statement<'a>>, ctx: &TraverseCtx<'a>) {}
            #[inline]
            fn exit_statements(&mut self, node: &mut Vec<'a, Statement<'a>>, ctx: &TraverseCtx<'a>) {}
        }
    `;
}

function generateAncestorsCode(types) {
    const variantNamesForEnums = Object.create(null);
    let enumVariants = '',
        isFunctions = '',
        ancestorTypes = '',
        discriminant = 1;
    for (const type of Object.values(types)) {
        if (type.kind === 'enum') continue;

        // TODO: Don't create `Ancestor`s for types which are never a parent
        // e.g. `IdentifierReference`
        const typeNameScreaming = camelToScreaming(type.name);
        for (const field of type.fields) {
            const offsetVarName = `OFFSET_${typeNameScreaming}_${field.name.toUpperCase()}`;
            field.offsetVarName = offsetVarName;
            ancestorTypes += `pub(crate) const ${offsetVarName}: usize = offset_of!(${type.name}, ${field.rawName});\n`;
        }

        const variantNames = [];
        for (const field of type.fields) {
            const fieldTypeName = unwrapTypeName(field.type),
                fieldType = types[fieldTypeName];
            if (!fieldType) continue;

            let methodsCode = '';
            for (const otherField of type.fields) {
                if (otherField === field) continue;

                methodsCode += `
                    #[inline]
                    pub fn ${otherField.rawName}(&self) -> &${otherField.rawType} {
                        unsafe {
                            &*(
                                (self.0 as *const u8).add(${otherField.offsetVarName})
                                as *const ${otherField.rawType}
                            )
                        }
                    }
                `;
            }

            const lifetime = type.hasLifetime ? "<'a>" : '',
                structName = `${type.name}Without${snakeToCamel(field.name)}${lifetime}`;

            ancestorTypes += `
                #[repr(transparent)]
                #[derive(Debug)]
                pub struct ${structName}(
                    pub(crate) *const ${type.name}${lifetime}
                );

                impl${lifetime} ${structName} {
                    ${methodsCode}
                }
            `;

            const variantName = `${type.name}${snakeToCamel(field.name)}`;
            variantNames.push(variantName);

            enumVariants += `${variantName}(${structName}) = ${discriminant},\n`;
            field.ancestorDiscriminant = discriminant;
            discriminant++;

            if (fieldType.kind === 'enum') {
                (variantNamesForEnums[fieldTypeName] || (variantNamesForEnums[fieldTypeName] = []))
                    .push(variantName);
            }
        }

        if (variantNames.length > 0) {
            isFunctions += `
                #[inline]
                pub fn is_${camelToSnake(type.name)}(&self) -> bool {
                    matches!(self, ${variantNames.map(name => `Self::${name}(_)`).join(' | ')})
                }
            `;
        }
    }

    for (const [typeName, variantNames] of Object.entries(variantNamesForEnums)) {
        isFunctions += `
            #[inline]
            pub fn is_via_${camelToSnake(typeName)}(&self) -> bool {
                matches!(self, ${variantNames.map(name => `Self::${name}(_)`).join(' | ')})
            }
        `;
    }

    const discriminantType = discriminant <= 256 ? 'u8' : 'u16';

    return `
        ${PREAMBLE}

        #![allow(
            unsafe_code,
            clippy::missing_safety_doc,
            clippy::ptr_as_ptr,
            clippy::undocumented_unsafe_blocks,
            clippy::cast_ptr_alignment
        )]

        // TODO: Remove unneeded offset consts, then remove next line
        #![allow(dead_code)]

        use memoffset::offset_of;

        use oxc_allocator::{Box, Vec};
        #[allow(clippy::wildcard_imports)]
        use oxc_ast::ast::*;
        use oxc_span::{Atom, SourceType, Span};
        use oxc_syntax::operator::{
            AssignmentOperator, BinaryOperator, LogicalOperator, UnaryOperator, UpdateOperator,
        };

        pub(crate) type AncestorDiscriminant = ${discriminantType};

        /// Ancestor type used in AST traversal.
        ///
        /// Encodes both the type of the parent, and child's location in the parent.
        /// i.e. variants for \`BinaryExpressionLeft\` and \`BinaryExpressionRight\`, not just \`BinaryExpression\`.
        #[repr(C, ${discriminantType})]
        #[derive(Debug)]
        pub enum Ancestor<'a> {
            None = 0,
            ${enumVariants}
        }

        impl<'a> Ancestor<'a> {
            ${isFunctions}
        }

        ${ancestorTypes}
    `;
}

function generateWalkFunctionsCode(types) {
    let walkMethods = '';
    for (const type of Object.values(types)) {
        const snakeName = camelToSnake(type.name),
            ty = toTypeName(type);
        if (type.kind === 'struct') {
            const visitedFields = type.fields.filter(field => unwrapTypeName(field.type) in types);

            const fieldsCodes = visitedFields.map((field, index) => {
                const {name: fieldTypeName, wrappers: fieldTypeWrappers} = typeAndWrappers(field.type);

                const retagCode = index === 0 ? '' : `ctx.retag_stack(${field.ancestorDiscriminant});`,
                    fieldCode = `(node as *mut u8).add(ancestor::${field.offsetVarName}) as *mut ${field.type}`;

                if (fieldTypeWrappers[0] === 'Option') {
                    const remainingWrappers = fieldTypeWrappers.slice(1);

                    let walkCode;
                    if (remainingWrappers.length === 1 && remainingWrappers[0] === 'Vec') {
                        if (fieldTypeName === 'Statement') {
                            // Special case for `Option<Vec<Statement>>`
                            walkCode = `walk_statements(traverser, field as *mut _, ctx);`;
                        } else {
                            walkCode = `
                                for item in field.iter_mut() {
                                    walk_${camelToSnake(fieldTypeName)}(traverser, item as *mut _, ctx);
                                }
                            `.trim();
                        }
                    } else if (remainingWrappers.length === 1 && remainingWrappers[0] === 'Box') {
                        walkCode = `walk_${camelToSnake(fieldTypeName)}(traverser, (&mut **field) as *mut _, ctx);`;
                    } else if (remainingWrappers.length > 0) {
                        walkCode = `todo!("TODO: ${field.type}");`;
                    } else {
                        walkCode = `walk_${camelToSnake(fieldTypeName)}(traverser, field as *mut _, ctx);`;
                    }

                    return `
                        if let Some(field) = &mut *(${fieldCode}) {
                            ${retagCode}
                            ${walkCode}
                        }
                    `;
                }

                if (fieldTypeWrappers[0] === 'Vec') {
                    const remainingWrappers = fieldTypeWrappers.slice(1);

                    let walkVecCode;
                    if (remainingWrappers.length === 0 && fieldTypeName === 'Statement') {
                        // Special case for `Vec<Statement>`
                        walkVecCode = `walk_statements(traverser, ${fieldCode}, ctx);`
                    } else {
                        let walkCode = `walk_${camelToSnake(fieldTypeName)}(traverser, item as *mut _, ctx);`,
                            iterModifier = '';
                        if (remainingWrappers.length === 1 && remainingWrappers[0] === 'Option') {
                            iterModifier = '.flatten()';
                        } else if (remainingWrappers.length > 0) {
                            walkCode = `todo!("TODO: ${field.type}");`;
                        }
                        walkVecCode = `
                            for item in (*(${fieldCode})).iter_mut()${iterModifier} {
                                ${walkCode}
                            }
                        `.trim();
                    }

                    return `
                        ${retagCode}
                        ${walkVecCode}
                    `;
                }

                if (fieldTypeWrappers.length === 1 && fieldTypeWrappers[0] === 'Box') {
                    return `
                        ${retagCode}
                        walk_${camelToSnake(fieldTypeName)}(
                            traverser, (&mut **(${fieldCode})) as *mut _, ctx
                        );
                    `;
                }

                if (fieldTypeWrappers.length > 0) return `todo!("TODO: ${field.type}");`;

                return `
                    ${retagCode}
                    walk_${camelToSnake(fieldTypeName)}(traverser, ${fieldCode}, ctx);
                `;
            });

            if (visitedFields.length > 0) {
                const field = visitedFields[0],
                    fieldCamelName = snakeToCamel(field.name);
                fieldsCodes.unshift(`
                    ctx.push_stack(
                        Ancestor::${type.name}${fieldCamelName}(
                            ancestor::${type.name}Without${fieldCamelName}(node)
                        )
                    );
                `);
                fieldsCodes.push('ctx.pop_stack();');
            }

            walkMethods += `
                pub(crate) unsafe fn walk_${snakeName}<'a, Tr: Traverse<'a>>(
                    traverser: &mut Tr,
                    node: *mut ${ty},
                    ctx: &mut TraverseCtx<'a>
                ) {
                    traverser.enter_${snakeName}(&mut *node, ctx);
                    ${fieldsCodes.join('\n')}
                    traverser.exit_${snakeName}(&mut *node, ctx);
                }
            `.replace(/\n\s*\n+/g, '\n');
        } else if (type.kind === 'enum') {
            const variantCodes = type.variants.map((variant) => {
                const {name: variantTypeName, wrappers: fieldTypeWrappers} = typeAndWrappers(variant.type),
                    variantType = types[variantTypeName];

                let unboxedCode;
                if (fieldTypeWrappers.length === 1 && fieldTypeWrappers[0] === 'Box') {
                    unboxedCode = '(&mut **node)';
                } else if (fieldTypeWrappers.length === 0) {
                    unboxedCode = 'node';
                }

                const walkCode = variantType && unboxedCode
                    ? `walk_${camelToSnake(variantTypeName)}(traverser, ${unboxedCode} as *mut _, ctx)`
                    : `todo!("TODO: ${variant.type}")`;
                return `${type.name}::${variant.name}(node) => ${walkCode},`;
            });

            const missingVariants = [];
            for (const inheritedTypeName of type.inherits) {
                // Recurse into nested inherited types
                const variantMatches = [],
                    inheritedFrom = [inheritedTypeName];
                for (let i = 0; i < inheritedFrom.length; i++) {
                    const inheritedTypeName = inheritedFrom[i],
                        inheritedType = types[inheritedTypeName];
                    if (!inheritedType || inheritedType.kind !== 'enum') {
                        missingVariants.push(inheritedTypeName);
                    } else {
                        variantMatches.push(...inheritedType.variants.map(
                            variant => `${type.name}::${variant.name}(_)`
                        ));
                        inheritedFrom.push(...inheritedType.inherits);
                    }
                }

                variantCodes.push(
                    `${variantMatches.join(' | ')} => `
                    + `walk_${camelToSnake(inheritedTypeName)}(traverser, node as *mut _, ctx),`
                );
            }

            if (missingVariants.length > 0) {
                variantCodes.push(`_ => todo!("TODO: Missing ${missingVariants.join(', ')}"),`);
            }

            walkMethods += `
                pub(crate) unsafe fn walk_${snakeName}<'a, Tr: Traverse<'a>>(traverser: &mut Tr, node: *mut ${ty}, ctx: &mut TraverseCtx<'a>) {
                    traverser.enter_${snakeName}(&mut *node, ctx);
                    match &mut *node {
                        ${variantCodes.join('\n')}
                    }
                    traverser.exit_${snakeName}(&mut *node, ctx);
                }
            `;
        } else {
            throw new Error(`Unexpected kind for ${type.name}`);
        }
    }

    return `
        ${PREAMBLE}

        #![allow(
            unsafe_code,
            clippy::missing_safety_doc,
            clippy::missing_panics_doc,
            clippy::undocumented_unsafe_blocks,
            clippy::semicolon_if_nothing_returned,
            clippy::ptr_as_ptr,
            clippy::borrow_as_ptr,
            clippy::cast_ptr_alignment
        )]

        use oxc_allocator::Vec;
        #[allow(clippy::wildcard_imports)]
        use oxc_ast::ast::*;

        use crate::{ancestor, Ancestor, Traverse, TraverseCtx};

        ${walkMethods}

        pub(crate) unsafe fn walk_statements<'a, Tr: Traverse<'a>>(
            traverser: &mut Tr,
            stmts: *mut Vec<'a, Statement<'a>>,
            ctx: &mut TraverseCtx<'a>
        ) {
            traverser.enter_statements(&mut *stmts, ctx);
            for stmt in (*stmts).iter_mut() {
                walk_statement(traverser, stmt, ctx);
            }
            traverser.exit_statements(&mut *stmts, ctx);
        }
    `;
}

async function getTypesFromCode() {
    const codeDirPath = pathJoin(fileURLToPath(import.meta.url), '../../../oxc_ast/src/ast/');
    const filenames = ['js.rs', 'jsx.rs', 'literal.rs', 'ts.rs'];

    // Parse type defs from Rust files
    const types = Object.create(null);
    for (const filename of filenames) {
        const code = await readFile(`${codeDirPath}${filename}`, 'utf8'),
            lines = code.split(/\r?\n/);
        for (let i = 0; i < lines.length; i++) {
            if (lines[i] === '#[visited_node]') {
                let match;
                while (true) {
                    match = lines[++i].match(/^pub (enum|struct) (.+?)(<'a>)? \{/);
                    if (match) break;
                }
                const [, kind, name, lifetimeStr] = match,
                    hasLifetime = !!lifetimeStr;
                const itemLines = [];
                while (true) {
                    const line = lines[++i].replace(/\/\/.*$/, '').replace(/\s+/g, ' ').trim();
                    if (line === '}') break;
                    if (line !== '') itemLines.push(line);
                }

                if (kind === 'enum') {
                    const variants = [],
                        inherits = [];
                    for (const line of itemLines) {
                        const match = line.match(/^(.+?)\((.+?)\)(?: ?= ?(\d+))?,$/);
                        if (match) {
                            let [, name, type, discriminant] = match;
                            type = type.replace(/<'a>/g, '').replace(/<'a,\s*/g, '<');
                            discriminant = discriminant ? +discriminant : null;
                            variants.push({name, type, discriminant});
                        } else {
                            const match2 = line.match(/^@inherit ([A-Za-z]+)$/);
                            assert(match2, `Cannot parse line ${i} in '${filename}' as enum variant: '${line}'`);
                            inherits.push(match2[1]);
                        }
                    }
                    types[name] = {kind: 'enum', name, hasLifetime, variants, inherits};
                } else {
                    const fields = [];
                    for (let i = 0; i < itemLines.length; i++) {
                        const line = itemLines[i];
                        if (line.startsWith('#[')) {
                            while (!itemLines[i].endsWith(']')) {
                                i++;
                            }
                            continue;
                        }

                        const match = line.match(/^pub ((?:r#)?([a-z_]+)): (.+),(?: ?\/\/.+)?$/);
                        assert(match, `Cannot parse line ${i} in '${filename}' as struct field: '${line}'`);
                        const [, rawName, name, rawType] = match,
                            type = rawType.replace(/<'a>/g, '').replace(/<'a, ?/g, '<');
                        fields.push({name, type, rawName, rawType});
                    }
                    types[name] = {kind: 'struct', name, hasLifetime, fields};
                }
            }
        }
    }
    return types;
}

function typeAndWrappers(name) {
    const wrappers = [];
    while (true) {
        const match = name.match(/^(.+?)<(.+)>$/);
        if (!match) break;
        wrappers.push(match[1]);
        name = match[2];
    }
    return {name, wrappers};
}

function unwrapTypeName(name) {
    return typeAndWrappers(name).name;
}

function toTypeName(type) {
    let ty = type.name;
    if (type.hasLifetime) ty += "<'a>";
    return ty;
}

function camelToSnake(name) {
    let prefixLen = 1;
    for (const prefix of ['TS', 'JSX', 'JS']) {
        if (name.startsWith(prefix)) {
            prefixLen = prefix.length;
            break;
        }
    }
    return name.slice(0, prefixLen).toLowerCase()
        + name.slice(prefixLen).replace(/[A-Z]/g, c => `_${c.toLowerCase()}`);
}

function camelToScreaming(name) {
    return camelToSnake(name).toUpperCase();
}

function snakeToCamel(name) {
    let prefixLen = 0;
    for (const prefix of ['TS', 'JSX', 'JS']) {
        if (name.startsWith(`${prefix.toLowerCase()}_`)) {
            prefixLen = prefix.length + 1;
            break;
        }
    }
    return name.slice(0, prefixLen + 1).toUpperCase()
        + name.slice(prefixLen + 1).replace(/_([a-z])/g, (_, c) => c.toUpperCase());
}

async function writeToFile(filename, code) {
    const path = pathJoin(outputDirPath, filename);
    console.log('Saving:', path);
    await writeFile(path, code);
    await execAsync(`rustfmt ${JSON.stringify(path)}`);
}
